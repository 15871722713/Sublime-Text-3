{
	"folder_history":
	[
		"/D/desktop/genieacs-sim",
		"/D/hgu_autotestc103",
		"/C/Users/cienet/AppData/Roaming/Sublime Text 3/Packages/SFTP",
		"/C/Users/cienet/AppData/Roaming/Sublime Text 3/Packages/SFTP/sftp",
		"/D/desktop/py_test",
		"/D/desktop/Autotest",
		"/C/Users/cienet/Desktop/openacs",
		"/C/Users/cienet/Desktop/baacloud",
		"//10.182.34.15/d$/FHATP/user/hgu_autotestc103/Service/WiFi/solocase",
		"//10.182.33.15/d$/FHATP/user/hgu_autotestc103/Lib/general/third_party_files",
		"/C/Users/cienet/Desktop/daily_test_stable",
		"//10.182.33.14/d$/FHATP/user/hgu_autotestb103",
		"/C/Users/cienet/Desktop/genieacs-services",
		"/C/Users/cienet/Desktop/genieacs",
		"/C/Python/Lib/logging",
		"/C/Users/cienet/Desktop/Autotest",
		"/C/Python/Lib/site-packages/scapy",
		"//10.182.33.15/d$/autotest",
		"/C/Users/cienet/AppData/Roaming/Sublime Text 3",
		"/C/Users/cienet/Desktop/hgu_autotest",
		"/C/Python/Lib/site-packages/selenium",
		"//10.182.33.15/d$/FHATP/user/hgu_autotestc103",
		"/C/Users/cienet/AppData/Roaming/Sublime Text 3/Packages",
		"//10.182.34.15/d$/FHATP/user/hgu_autotestc103",
		"/C/Python/Lib/site-packages/paramiko",
		"/C/Users/cienet/Desktop/py_test"
	],
	"last_version": 3211,
	"last_window_id": 115,
	"log_indexing": false,
	"settings":
	{
		"new_window_height": 299.0,
		"new_window_settings":
		{
			"auto_complete":
			{
				"selected_items":
				[
					[
						"type",
						"type_\tparam"
					],
					[
						"dataw2",
						"data_wan_conx2\tstatement"
					]
				]
			},
			"build_system_choices":
			[
				[
					[
						[
							"Anaconda Python Builder",
							""
						],
						[
							"Packages/Python/Python.sublime-build",
							""
						],
						[
							"Packages/Python/Python.sublime-build",
							"Syntax Check"
						]
					],
					[
						"Packages/Python/Python.sublime-build",
						""
					]
				]
			],
			"build_varint": "",
			"command_palette":
			{
				"height": 0.0,
				"last_filter": "",
				"selected_items":
				[
					[
						"pci",
						"Package Control: Install Package"
					],
					[
						"pcr",
						"Package Control: Remove Package"
					],
					[
						"Package Control: ",
						"Package Control: Disable Package"
					],
					[
						"pi",
						"Package Control: Install Package"
					],
					[
						"pacc",
						"Install Package Control"
					]
				],
				"width": 0.0
			},
			"console":
			{
				"height": 458.0,
				"history":
				[
				]
			},
			"distraction_free":
			{
				"menu_visible": true,
				"show_minimap": false,
				"show_open_files": false,
				"show_tabs": false,
				"side_bar_visible": false,
				"status_bar_visible": false
			},
			"file_history":
			[
				"/D/hgu_autotestc103/Service/Global.py",
				"/D/desktop/genieacs-sim/methods.js",
				"/D/desktop/genieacs-sim/genieacs-sim",
				"/D/desktop/genieacs-sim/simulator.js",
				"/D/desktop/genieacs-sim/data_model_202BC1-BM632w-8KA8WA1151100043.json",
				"/D/desktop/新建文件夹/ayu-mirage.sublime-theme",
				"/D/desktop/新建文件夹/ayu.skins",
				"/D/desktop/新建文件夹/.supports-a-file-icon-customization",
				"/D/desktop/新建文件夹/Icons.py",
				"/D/desktop/新建文件夹/messages.json",
				"/D/desktop/新建文件夹/tsconfig.json",
				"/D/desktop/新建文件夹/package.json",
				"/C/Users/cienet/AppData/Roaming/Sublime Text 3/Installed Packages/ayu.sublime-package",
				"/C/Users/cienet/AppData/Roaming/Sublime Text 3/Packages/SFTP/sftp/commands.pyc",
				"/D/desktop/sftp/commands.pyc",
				"/D/hgu_autotestc103/Lib/Service/AC/bizAC.py",
				"/D/hgu_autotestc103/Lib/general/log/bizLog.py",
				"/D/hgu_autotestc103/Lib/general/log/unilogintf.py",
				"/D/hgu_autotestc103/Service/AC/solocase/AC_IPFilter_Black_003.py",
				"/D/hgu_autotestc103/Service/AC/solocase/AC_IPFilter_Black_004.py",
				"/D/hgu_autotestc103/Service/AC/solocase/AC_IPFilter_White_001.py",
				"/D/hgu_autotestc103/Service/AC/solocase/AC_IPFilter_White_003.py",
				"/D/hgu_autotestc103/Service/AC/solocase/AC_ComplexFilter_Black_001.py",
				"/D/hgu_autotestc103/Service/AC/solocase/AC_ComplexFilter_Black_002.py",
				"/D/hgu_autotestc103/Service/AC/solocase/AC_IPFilter_White_004.py",
				"/D/hgu_autotestc103/Service/AC/solocase/AC_ComplexFilter_White_001.py",
				"/D/hgu_autotestc103/Service/AC/solocase/AC_ComplexFilter_White_002.py",
				"/D/hgu_autotestc103/Service/AC/solocase/AC_ComplexFilter_White_003.py",
				"/D/hgu_autotestc103/Service/AC/solocase/AC_IPFilter_Black_001.py",
				"/D/hgu_autotestc103/Service/AC/solocase/AC_IPFilter_Black_002.py",
				"/D/hgu_autotestc103/Service/AC/solocase/AC_PortFilter_Black_003.py",
				"/D/hgu_autotestc103/Service/AC/solocase/AC_PortFilter_Black_002.py",
				"/D/hgu_autotestc103/Service/AC/solocase/AC_PortFilter_Black_004.py",
				"/D/hgu_autotestc103/Service/AC/solocase/AC_PortFilter_White_003.py",
				"/D/hgu_autotestc103/Service/AC/solocase/AC_PortFilter_White_004.py",
				"/D/hgu_autotestc103/Service/AC/solocase/AC_PortFilter_Black_001.py",
				"/D/hgu_autotestc103/Service/AC/solocase/AC_TwoFilter_White_015.py",
				"/D/hgu_autotestc103/Service/AC/solocase/AC_TwoFilter_White_014.py",
				"/D/hgu_autotestc103/Service/AC/solocase/AC_TwoFilter_White_016.py",
				"/D/hgu_autotestc103/Service/AC/solocase/AC_TwoFilter_White_017.py",
				"/D/hgu_autotestc103/Service/AC/solocase/AC_ThreeFilter_Black_002.py",
				"/D/hgu_autotestc103/Service/AC/solocase/AC_ThreeFilter_Black_001.py",
				"/D/hgu_autotestc103/Service/AC/solocase/AC_ThreeFilter_Black_003.py",
				"/D/hgu_autotestc103/Service/AC/solocase/AC_ThreeFilter_Black_004.py",
				"/D/hgu_autotestc103/Service/AC/solocase/AC_ThreeFilter_Black_005.py",
				"/D/hgu_autotestc103/Service/AC/solocase/AC_ThreeFilter_Black_006.py",
				"/D/hgu_autotestc103/Service/AC/solocase/AC_ThreeFilter_Black_007.py",
				"/D/hgu_autotestc103/Service/AC/solocase/AC_ThreeFilter_Black_008.py",
				"/D/hgu_autotestc103/Service/AC/solocase/AC_ThreeFilter_Black_010.py",
				"/D/hgu_autotestc103/Service/AC/solocase/AC_ThreeFilter_Black_009.py",
				"/D/hgu_autotestc103/Service/AC/solocase/AC_ThreeFilter_White_001.py",
				"/D/hgu_autotestc103/Service/AC/solocase/AC_ThreeFilter_White_002.py",
				"/D/hgu_autotestc103/Service/AC/solocase/AC_ThreeFilter_White_003.py",
				"/D/hgu_autotestc103/Service/AC/solocase/AC_ThreeFilter_White_004.py",
				"/D/hgu_autotestc103/Service/AC/solocase/AC_ThreeFilter_White_005.py",
				"/D/hgu_autotestc103/Service/AC/solocase/AC_ThreeFilter_White_006.py",
				"/D/hgu_autotestc103/Service/AC/solocase/AC_ThreeFilter_White_007.py",
				"/D/hgu_autotestc103/Service/AC/solocase/AC_ThreeFilter_White_008.py",
				"/D/hgu_autotestc103/Service/AC/solocase/AC_TwoFilter_Black_001.py",
				"/D/hgu_autotestc103/Service/AC/solocase/AC_TwoFilter_Black_003.py",
				"/D/hgu_autotestc103/Service/AC/solocase/AC_TwoFilter_Black_002.py",
				"/D/hgu_autotestc103/Service/AC/solocase/AC_TwoFilter_Black_005.py",
				"/D/hgu_autotestc103/Service/AC/solocase/AC_TwoFilter_Black_004.py",
				"/D/hgu_autotestc103/Service/AC/solocase/AC_TwoFilter_Black_007.py",
				"/D/hgu_autotestc103/Service/AC/solocase/AC_TwoFilter_Black_006.py",
				"/D/hgu_autotestc103/Service/AC/solocase/AC_TwoFilter_Black_008.py",
				"/D/hgu_autotestc103/Service/AC/solocase/AC_TwoFilter_Black_009.py",
				"/D/hgu_autotestc103/Service/AC/solocase/AC_TwoFilter_Black_011.py",
				"/D/hgu_autotestc103/Service/AC/solocase/AC_TwoFilter_Black_010.py",
				"/D/hgu_autotestc103/Service/AC/solocase/AC_TwoFilter_Black_013.py",
				"/D/hgu_autotestc103/Service/AC/solocase/AC_TwoFilter_Black_012.py",
				"/D/hgu_autotestc103/Service/AC/solocase/AC_TwoFilter_Black_014.py",
				"/D/hgu_autotestc103/Service/AC/solocase/AC_TwoFilter_Black_015.py",
				"/D/hgu_autotestc103/Service/AC/solocase/AC_TwoFilter_White_001.py",
				"/D/hgu_autotestc103/Service/AC/solocase/AC_TwoFilter_White_002.py",
				"/D/hgu_autotestc103/Service/AC/solocase/AC_TwoFilter_White_004.py",
				"/D/hgu_autotestc103/Service/AC/solocase/AC_TwoFilter_White_003.py",
				"/D/hgu_autotestc103/Service/AC/solocase/AC_TwoFilter_White_006.py",
				"/D/hgu_autotestc103/Service/AC/solocase/AC_TwoFilter_White_005.py",
				"/D/hgu_autotestc103/Service/AC/solocase/AC_TwoFilter_White_008.py",
				"/D/hgu_autotestc103/Service/AC/solocase/AC_TwoFilter_White_007.py",
				"/D/hgu_autotestc103/Service/AC/solocase/AC_TwoFilter_White_009.py",
				"/D/hgu_autotestc103/Service/AC/solocase/AC_TwoFilter_White_010.py",
				"/D/hgu_autotestc103/Service/AC/solocase/AC_TwoFilter_White_012.py",
				"/D/hgu_autotestc103/Service/AC/solocase/AC_TwoFilter_White_013.py",
				"/D/hgu_autotestc103/Service/AC/solocase/AC_TwoFilter_White_011.py",
				"/C/Users/cienet/AppData/Roaming/Sublime Text 3/Packages/SFTP/sftp/commands.py",
				"/D/desktop/直真日志/ACSServer.traces",
				"/D/desktop/直真日志/TR069Adaptor.traces",
				"/D/desktop/直真日志/ITFService.traces",
				"/C/Users/cienet/AppData/Roaming/Sublime Text 3/Packages/User/Anaconda.sublime-settings",
				"/D/hgu_autotestc103/Lib/Service/Start/bizStart.py",
				"/D/hgu_autotestc103/Lib/Service/AC/impACWeb.py",
				"/C/Users/cienet/AppData/Roaming/Sublime Text 3/Packages/Sublimerge Pro/Sublimerge.sublime-settings",
				"/C/Users/cienet/AppData/Roaming/Sublime Text 3/Packages/SFTP/SFTP.sublime-settings",
				"/C/Users/cienet/AppData/Roaming/Sublime Text 3/Packages/User/SFTP.sublime-settings",
				"/D/desktop/电信直真日志/TR069Adaptor.traces",
				"/D/desktop/电信直真日志/ACSServer.traces",
				"/D/desktop/电信直真日志/ITFService.traces",
				"/D/hgu_autotestc103/sftp-config.json",
				"/C/Users/cienet/AppData/Roaming/Sublime Text 3/Packages/SFTP/SFTP.py",
				"/C/Users/cienet/AppData/Roaming/Sublime Text 3/Packages/SublimeSimpleSync/SublimeSimpleSync.sublime-settings",
				"/C/Users/cienet/AppData/Roaming/Sublime Text 3/Packages/User/SublimeSimpleSync.sublime-settings",
				"/C/Users/cienet/Desktop/py_test/log01/__init__.py",
				"/C/Users/cienet/Desktop/py_test/conftest.py",
				"/C/Users/cienet/Desktop/py_test/pytest.ini",
				"/C/Users/cienet/Desktop/py_test/test_py_001.py",
				"/C/Users/cienet/Desktop/烽火/系统启动/资料/模块.py",
				"/C/Users/cienet/Desktop/py_test/test002.py",
				"/C/Users/cienet/Desktop/py_test/log01/test.log",
				"/C/Users/cienet/Desktop/py_test/log01/boss.log",
				"/C/Users/cienet/Desktop/py_test/log01/coder.log",
				"/C/Users/cienet/Desktop/py_test/log01",
				"/C/Users/cienet/Desktop/test.py",
				"/C/Users/cienet/Desktop/烽火/系统启动/资料/test.py",
				"/C/Users/cienet/Desktop/py_test/assets/console.py",
				"/C/Users/cienet/Desktop/py_test/report.html",
				"/C/Users/cienet/Desktop/py_test/bbb.py",
				"/C/Users/cienet/AppData/Roaming/Sublime Text 3/Packages/User/Word Highlight.sublime-settings",
				"/C/Users/cienet/AppData/Roaming/Sublime Text 3/Packages/WordHighlight/Word Highlight.sublime-settings",
				"/C/Users/cienet/AppData/Roaming/Sublime Text 3/Packages/SublimeCodeIntel/SublimeCodeIntel.sublime-settings",
				"/c/Python/lib/site-packages/pexpect/__init__.py",
				"/C/Users/cienet/AppData/Roaming/Sublime Text 3/Packages/CTags/CTags.sublime-settings",
				"//10.182.33.15/d$/FHATP/user/hgu_autotestc103/Lib/Service/BRDGMC/bizBRDGMC.py",
				"/C/Users/cienet/AppData/Roaming/Sublime Text 3/Packages/User/CTags.sublime-settings",
				"/C/Users/cienet/AppData/Roaming/Sublime Text 3/Packages/User/Default (Windows).sublime-keymap",
				"//10.182.33.15/d$/FHATP/user/hgu_autotestc103/Lib/general/hgu_telnet.py",
				"//10.182.33.15/d$/FHATP/user/hgu_autotestc103/Config/site_para.py"
			],
			"find":
			{
				"height": 34.0
			},
			"find_in_files":
			{
				"height": 261.0,
				"where_history":
				[
					"D:\\hgu_autotestc103\\Service\\Start\\solocase",
					"<open files>"
				]
			},
			"find_state":
			{
				"case_sensitive": false,
				"find_history":
				[
					"[true],",
					"[false],",
					"WiMAX",
					"WANDSLInterfaceConfig",
					"InternetGatewayDevice.WANDevice.1.WANDSLInterfaceConfig.",
					"GetParameterValues",
					"table",
					"tab",
					"teab",
					"sidebar",
					"side",
					"sidebar_tree",
					"if self.other.ping_check(self.p, loss=True, times=60):\n            logger.show_opr_one_step(AbsInCo('process', 'qry'), '1.PC1长ping外网域名{Var1}。'.format(Var1=self.Var1))\n        else:\n            logger.show_opr_one_step(AbsInCo('process', 'qry-quit'), '1.PC1长ping外网域名{Var1}。'.format(Var1=self.Var1))",
					"self.p",
					"(AbsHGUTCSBase)"
				],
				"highlight": true,
				"in_selection": false,
				"preserve_case": false,
				"regex": false,
				"replace_history":
				[
					"[true, \"0\", \"xsd:unsignedInt\"],",
					"[true, \"0\", \"xsd:unsignedInt\"]",
					"if self.other.ping_check(self.p, loss=True, times=60):\n            self.assertion(AbsInCo('process', 'success'), '1.PC1长ping外网域名{Var1}。'.format(Var1=self.Var1))\n        else:\n            self.assertion(AbsInCo('process', 'fail'), '1.PC1长ping外网域名{Var1}。'.format(Var1=self.Var1))",
					"(ClearCFGMixIn)"
				],
				"reverse": false,
				"show_context": true,
				"use_buffer2": true,
				"whole_word": false,
				"wrap": true
			},
			"incremental_find":
			{
				"height": 34.0
			},
			"input":
			{
				"height": 71.0
			},
			"menu_visible": true,
			"output.exec":
			{
				"height": 391.0
			},
			"output.find_results":
			{
				"height": 0.0
			},
			"output.sftp":
			{
				"height": 151.0
			},
			"pinned_build_system": "",
			"replace":
			{
				"height": 64.0
			},
			"save_all_on_build": true,
			"select_file":
			{
				"height": 0.0,
				"last_filter": "",
				"selected_items":
				[
					[
						"glo",
						"Service\\Global.py"
					],
					[
						"bizstart",
						"Lib\\Service\\Start\\bizStart.py"
					],
					[
						"bizac",
						"Lib\\Service\\AC\\bizAC.py"
					],
					[
						"glob",
						"Service\\Global.py"
					],
					[
						"abshgu",
						"Lib\\general\\util_basic\\absHGUProduct.py"
					],
					[
						"hgutel",
						"Lib\\general\\hgu_telnet.py"
					],
					[
						"impwe",
						"Lib\\general\\util_basic\\impWEBChn.py"
					]
				],
				"width": 0.0
			},
			"select_project":
			{
				"height": 0.0,
				"last_filter": "",
				"selected_items":
				[
				],
				"width": 0.0
			},
			"select_symbol":
			{
				"height": 0.0,
				"last_filter": "",
				"selected_items":
				[
				],
				"width": 0.0
			},
			"show_minimap": true,
			"show_open_files": false,
			"show_tabs": true,
			"side_bar_visible": true,
			"side_bar_width": 269.0,
			"status_bar_visible": true,
			"template_settings":
			{
			}
		},
		"new_window_width": 883.0
	},
	"windows":
	[
		{
			"auto_complete":
			{
				"selected_items":
				[
					[
						"Im",
						"ImpStartOther\tclass"
					],
					[
						"type",
						"type_\tparam"
					],
					[
						"dataw2",
						"data_wan_conx2\tstatement"
					]
				]
			},
			"buffers":
			[
				{
					"file": "/D/desktop/py_test/test001.py",
					"settings":
					{
						"buffer_size": 1057,
						"encoding": "UTF-8",
						"line_ending": "Windows"
					}
				},
				{
					"file": "/D/desktop/py_test/bbb.py",
					"settings":
					{
						"buffer_size": 2949,
						"encoding": "UTF-8",
						"line_ending": "Unix"
					}
				},
				{
					"file": "/D/desktop/test.py",
					"settings":
					{
						"buffer_size": 11903,
						"encoding": "UTF-8",
						"line_ending": "Unix"
					}
				},
				{
					"file": "/D/desktop/py_test/test002.py",
					"settings":
					{
						"buffer_size": 618344,
						"encoding": "UTF-8",
						"line_ending": "Windows"
					}
				},
				{
					"contents": "import sublime, sublime_plugin, os, subprocess, re, sys, hmac, binascii, time, traceback, tempfile, shutil, difflib, codecs\nfrom itertools import cycle\ntry:\n    from itertools import izip\n    str_cls = unicode\n    str_clses = ['unicode', 'str']\n    st_version = 2\nexcept ImportError:\n    izip = zip\n    xrange = range\n    str_cls = str\n    str_clses = ['str', 'bytes']\n    st_version = 3\n\nif os.name != 'nt':\n    import unicodedata\nfrom .errors import AuthenticationError, BinaryMissingError, ConnectionError, DisconnectionError, encoding_error, handle_exception, NotFoundError, PermissionError\nfrom .panel_printer import PanelPrinter, ProgressThread\nfrom .threads import HookedThread, SyncThread, ThreadActivity, ThreadTracker, unset_current_thread\nfrom .debug import debug_print, get_debug\nfrom .times import time_diff\nfrom .views import get_view_by_group_index\nfrom .paths import canonicalize, dirname, fix_windows_path, ignore_paths, ignore_rm_paths, is_dir, is_root, local_to_remote, path_type, remote_to_local\nfrom .config import build_config, find_config, get_default_config, get_server_config_folder, load_config, parse_config, prepare_server_config, setup_tmp_dir\nfrom .sftp_transport import SFTP\nfrom .ftp_transport import FTP\nfrom .vcs import Hg, Git, SVN\ntransports = {'SFTP': SFTP,\n 'FTP': FTP}\nif 'ssl' in sys.modules:\n    from .ftps_transport import FTPS\n    transports['FTPS'] = FTPS\n\ndef show_qp(window, choices, on_done):\n\n    def show_timeout():\n        window.show_quick_panel(choices, on_done)\n\n    sublime.set_timeout(show_timeout, 10)\n\n\nclass SftpCommand(object):\n    connections = {}\n    identifiers = {}\n    usage = {}\n    remote_roots = {}\n    remote_time_offsets = {}\n\n    @classmethod\n    def setup_elements(cls, config):\n        if not hasattr(SftpCommand, 'elements'):\n            SftpCommand.elements = [0,\n             config.get('email'),\n             'sftp_flags',\n             'ssh_key_file',\n             'psftp']\n            SftpCommand.elements.append('Sublime SFTP\\n\\nThanks for trying out Sublime SFTP. It is free to try, but a license must be purchased for continued use.\\n\\nPlease visit http://sublime.wbond.net/sftp for details.')\n            SftpCommand.elements.append(config.get('product_key'))\n            key = SftpCommand.elements[1]\n            if isinstance(key, str_cls):\n                key = key.encode('utf-8')\n            for element in SftpCommand.elements[2:-2]:\n                key = hmac.new(element.encode('utf-8'), key).digest()\n\n            SftpCommand.elements[1] = key\n\n    def create_default_config(self, file):\n        handle = open(file, 'w')\n        handle.write(get_default_config(True))\n        handle.close()\n\n    def first_path(self, paths):\n        if paths is None or paths == []:\n            return\n        else:\n            return paths[0]\n\n    def get_path(self, paths=None, allow_multiple=False, view=None):\n        type_ = type(paths).__name__\n        if (paths is None or paths == []) and type_ not in str_clses:\n            if view is None:\n                if not hasattr(self, 'window'):\n                    return\n                view = self.window.active_view()\n                if view is None:\n                    if st_version == 3:\n                        return self.window.extract_variables().get('file')\n                    return\n            return view.file_name()\n        else:\n            if allow_multiple or type_ in str_clses:\n                return paths\n            return paths[0]\n\n    def has_config(self, path):\n        return bool(find_config(path, True))\n\n    def get_config(self, paths=None, quiet=False):\n        path = self.get_path(paths)\n        config, config_file = load_config(path)\n        if config is None:\n            return\n        else:\n            config_dir = dirname(config_file)\n            return build_config(config, config_dir, config_file, quiet)\n\n    def save_files(self, files=[]):\n        if not isinstance(files, list):\n            files = [\n             files]\n        window = self.window if hasattr(self, 'window') else self.view.window()\n        original_view = window.active_view()\n        for view in window.views():\n            file = view.file_name()\n            if not (files and file not in files):\n                if not file:\n                    continue\n                if find_config(file, True) and view.is_dirty():\n                    window.focus_view(view)\n                    view_settings = view.settings()\n                    view_settings.set('sftp_auto_save', True)\n                    view.run_command('save')\n                continue\n\n        if original_view:\n            window.focus_view(original_view)\n\n\nclass SftpThread(HookedThread):\n\n    def __init__(self, window_id, config, file, action, should_join=True, quiet=False, increment=True, reset_lcd=None, on_connect=None, on_fail=None, on_complete=None, hide=True, skip_ignore=False, skip_symlinks=True, mode=None):\n        self.window_id = window_id\n        self.printer = PanelPrinter.get(window_id)\n        self.config = config\n        self.file = file\n        self.action = action\n        self.quiet = quiet\n        self.result = None\n        self.connection = None\n        self.increment = increment\n        self.should_join = should_join\n        self.reset_lcd = reset_lcd\n        self.on_connect = on_connect\n        self.on_fail = on_fail\n        self.on_complete = on_complete\n        self.connection_id = str(window_id) + '-' + self.config['user'] + '@' + self.config['host'] + ':' + self.config['port']\n        self.hide = hide\n        self.failed = False\n        self.skip_ignore = skip_ignore\n        self.skip_symlinks = skip_symlinks\n        self.mode = mode\n        self.config_file_cancel = False\n        if self.action == 'put' and not self.config['allow_config_upload']:\n            files = [file] if not isinstance(file, list) else file\n            regexp = re.compile('(^|/|\\\\\\\\)(sftp-config(-alt\\\\d?)?\\\\.json|sftp-settings\\\\.json)$')\n            for f in files:\n                if re.search(regexp, f) is not None:\n                    self.config_file_cancel = True\n                    break\n\n        SftpCommand.setup_elements(self.config)\n        super(SftpThread, self).__init__()\n        return\n\n    @classmethod\n    def cleanup(cls):\n        for connection_id in SftpCommand.connections:\n            connection = SftpCommand.connections[connection_id]\n            connection.close()\n\n    def close_connection(self, identifier, dir, window_id, disconnected=False):\n        if not SftpCommand.usage.get(identifier):\n            return\n        SftpCommand.usage[identifier] -= 1\n        if SftpCommand.usage[identifier] and not disconnected:\n            return\n        debug_print('SFTP: Closing unused connection ' + identifier, 2)\n        if SftpCommand.connections.get(identifier):\n            SftpCommand.connections[identifier].close(disconnected)\n            debug_print('SFTP: Closed unused connection ' + identifier, 2)\n            del SftpCommand.connections[identifier]\n        if SftpCommand.identifiers.get(str(window_id) + '-' + dir):\n            del SftpCommand.identifiers[str(window_id) + '-' + dir]\n\n    def kill(self):\n        debug_print('SFTP: Killing connection ' + self.connection_id, 2)\n        self.connection.close()\n        dir = self.config['local_dir']\n        dir = str(self.window_id) + '-' + dir\n        identifier = SftpCommand.identifiers.get(dir, None)\n        if SftpCommand.identifiers.get(dir):\n            del SftpCommand.identifiers[dir]\n        if identifier:\n            del SftpCommand.connections[identifier]\n            del SftpCommand.usage[identifier]\n        ThreadTracker.set_current(self.window_id, None)\n        return\n\n    @unset_current_thread\n    def run(self):\n        self.start = time.time()\n        if self.should_join:\n            last_thread = ThreadTracker.get_last_added(self.window_id)\n            ThreadTracker.add(self)\n            if last_thread is not None:\n                debug_print('SFTP: Waiting for previous thread', 2)\n                last_thread.join()\n        if self.config_file_cancel:\n            self.printer.write('\\nCanceled since payload included one or more Sublime SFTP configuration files and the \"allow_config_upload\" is not set to true')\n\n            def do_config_file_cancel():\n                message = 'Sublime SFTP\\n\\nIt appears you are attempting to upload one or more Sublime SFTP config files that may contain sensitive information. To do so, you must set the \"allow_config_upload\" setting to true.'\n                sublime.error_message(message)\n\n            sublime.set_timeout(do_config_file_cancel, 10)\n            return\n        else:\n            debug_print('SFTP: Beginning file transfer thread', 2)\n            ThreadActivity(self, self.printer, 'SFTP Working')\n            self.printer.reset_hide()\n            ThreadTracker.set_current(self.window_id, self)\n            try:\n                try:\n                    if not self.make_connection():\n                        return\n                    debug_print('SFTP: Checking license key', 2)\n                    SftpCommand.setup_elements(self.config)\n                    do_show = False\n                    if self.action not in ('list', 'listr', 'llist', 'llistr', 'cwd'):\n                        SftpCommand.elements[0] += 1\n\n                        def zip_to_i(element):\n                            if isinstance(element, int):\n                                return element\n                            return ord(element)\n\n                        if sys.version_info >= (3, ):\n                            key_prefix = bytes([zip_to_i(x) ^ zip_to_i(y) for x, y in izip(SftpCommand.elements[1], cycle('22'))])\n                        else:\n                            key_prefix = ''.join([chr(zip_to_i(x) ^ zip_to_i(y)) for x, y in izip(SftpCommand.elements[1], cycle('22'))])\n                        key_prefix = binascii.hexlify(key_prefix)[:30]\n                        clen = 6\n                        chunks = [key_prefix[(i - 1) * clen:i * clen] for i in xrange(1, int(len(key_prefix) / clen + 1))]\n                        key_prefix = '-'.join(chunks).decode('utf-8')\n                        if SftpCommand.elements[0] > 0 and SftpCommand.elements[0] % 10 == 0 and key_prefix != SftpCommand.elements[(-1)]:\n\n                            def reg():\n                                if int(sublime.version()) >= 2190:\n                                    if sublime.ok_cancel_dialog(SftpCommand.elements[(-2)], 'Buy Now'):\n                                        sublime.active_window().run_command('open_url', {'url': 'http://wbond.net/sublime_packages/sftp/buy'})\n                                else:\n                                    sublime.error_message(SftpCommand.elements[(-2)])\n\n                            # sublime.set_timeout(reg, 1)\n                            do_show = True\n                    self.do_operation(do_show)\n                except (OSError, BinaryMissingError) as e:\n                    if self.on_fail:\n                        self.on_fail(e)\n                    self.close_connection(self.connection_id, self.config['local_dir'], self.window_id, isinstance(e, DisconnectionError))\n                    if isinstance(e, DisconnectionError):\n                        try:\n                            debug_print('SFTP: Reconnecting after disconnection', 2)\n                            if not self.make_connection():\n                                return\n                            self.do_operation()\n                        except OSError:\n                            self.printer.write('\\nMultiple disconnection errors, giving up')\n\n            except UnicodeDecodeError as e:\n                encoding_error(e)\n            except LookupError as e:\n                encoding_error(e)\n\n            return\n\n    def make_connection(self):\n        self.failed = True\n        old_identifier = SftpCommand.identifiers.get(str(self.window_id) + '-' + self.config['local_dir'], None)\n        if old_identifier is not None and self.connection_id != old_identifier:\n            self.close_connection(old_identifier, self.config['local_dir'], self.window_id)\n        self.connection = SftpCommand.connections.get(self.connection_id, None)\n        if self.connection and self.connection.closed:\n            self.close_connection(self.connection_id, self.config['local_dir'], self.window_id)\n            self.connection = None\n        if self.connection is None:\n            class_name = self.config['type'].upper()\n            class_object = transports[class_name]\n            debug_print('SFTP: Creating file transfer object', 2)\n            merged_config = self.config.copy()\n            merged_config['remote_time_offset'] = SftpCommand.remote_time_offsets.get(self.connection_id)\n            debug_print('SFTP: Configuration\\n    %s' % repr(merged_config), 2)\n            self.connection = class_object(self.printer, **merged_config)\n            try:\n                debug_print('SFTP: Starting connection', 2)\n                self.connection.connect()\n                debug_print('SFTP: Successful connected', 2)\n                SftpCommand.connections[self.connection_id] = self.connection\n            except (AuthenticationError, ConnectionError, BinaryMissingError) as e:\n                self.printer.error(e)\n                return False\n            except OSError as e:\n                self.close_connection(self.connection_id, self.config['local_dir'], self.window_id)\n                return False\n\n        if str(self.window_id) + '-' + self.config['local_dir'] not in SftpCommand.identifiers:\n            SftpCommand.identifiers[str(self.window_id) + '-' + self.config['local_dir']] = self.connection_id\n            if self.connection_id not in SftpCommand.usage:\n                SftpCommand.usage[self.connection_id] = 0\n            SftpCommand.usage[self.connection_id] += 1\n        if self.connection_id not in SftpCommand.remote_roots:\n            SftpCommand.remote_roots[self.connection_id] = []\n        if self.config['remote_dir'] not in SftpCommand.remote_roots[self.connection_id]:\n            try:\n                progress = ProgressThread(self.printer, '\\nValidating remote folder \"%s\"' % self.config['initial_remote_dir'])\n                initial_dir = self.connection.pwd()\n                self.connection.cd(self.config['initial_remote_dir'])\n                self.connection.ls(self.config['path_map'], config=self.config)\n                SftpCommand.remote_roots[self.connection_id].append(self.config['remote_dir'])\n            except (NotFoundError, PermissionError) as e:\n                progress.stop('failure (' + str(e) + ')')\n                progress.join()\n                self.connection.remote_time_offset = 0\n                output = '\\nInitial folder and contents:'\n                try:\n                    for path in self.connection.ls(self.config['path_map'], config=self.config):\n                        if path[0] == '.':\n                            path[0] = ''\n                        output += '\\n  \"%s%s\"' % (initial_dir, path[0])\n\n                    self.printer.write(output)\n                except (ConnectionError, NotFoundError) as e2:\n                    self.close_connection(self.connection_id, self.config['local_dir'], self.window_id)\n                    self.printer.write('\\nListing initial folder \"%s\" ... failure (%s)' % (initial_dir, str(e2)))\n\n                self.printer.error(e)\n                return False\n            except ConnectionError as e:\n                progress.stop('failure (%s)' % str(e))\n                progress.join()\n                self.close_connection(self.connection_id, self.config['local_dir'], self.window_id, True)\n                self.printer.error(e)\n                return False\n            except OSError as e:\n                is_ftp = self.config['type'] == 'ftp'\n                is_pasv = self.config.get('ftp_passive_mode') is not False\n                if isinstance(e, DisconnectionError) and is_ftp and is_pasv:\n                    e = OSError('Disconnected - possible PASV mode error, try setting ftp_passive_mode to false in sftp-config.json')\n                self.close_connection(self.connection_id, self.config['local_dir'], self.window_id)\n                progress.stop('failure (%s)' % str(e))\n                progress.join()\n                raise e\n            except (AttributeError, EOFError) as e:\n                backtrace = traceback.format_exc()\n                handle_exception('Unknown Error', backtrace)\n                self.close_connection(self.connection_id, self.config['local_dir'], self.window_id)\n                progress.stop('failure (Unknown Error)')\n                progress.join()\n                return False\n            except UnicodeDecodeError:\n                self.close_connection(self.connection_id, self.config['local_dir'], self.window_id)\n                progress.stop('failure (Encoding error)')\n                progress.join()\n                raise\n\n            progress.stop('success')\n            progress.join()\n        if self.connection_id not in SftpCommand.remote_time_offsets:\n            SftpCommand.remote_time_offsets[self.connection_id] = self.connection.remote_time_offset\n        if self.on_connect:\n            self.on_connect()\n        self.failed = False\n        return True\n\n    def do_operation(self, show=False):\n        self.failed = True\n        self.connection.debug(get_debug())\n        debug_print('SFTP: Starting operation ' + self.action, 2)\n        success, result = getattr(self.connection, self.action)(self.file, path_map=self.config['path_map'], chmod_dirs=self.config.get('dir_permissions'), chmod_files=self.config.get('file_permissions'), ignore_regex=self.config.get('ignore_regex') if not self.skip_ignore else None, quiet=self.quiet, config=self.config, skip_symlinks=self.skip_symlinks, mode=self.mode)\n        if show:\n\n            def do_print():\n                self.printer.write('\\nUNREGISTERED: Please visit http://sublime.wbond.net/sftp')\n\n            sublime.set_timeout(do_print, 1)\n        debug_print('SFTP: Finished operation ' + self.action, 2)\n        if self.hide:\n            sublime.set_timeout(lambda : self.printer.hide(self), 1)\n        if self.reset_lcd:\n            reset_lcd = self.reset_lcd\n            last_reset_lcd = None\n            while reset_lcd != last_reset_lcd:\n                last_reset_lcd = reset_lcd\n                try:\n                    self.connection.lcd(reset_lcd)\n                except NotFoundError:\n                    reset_lcd = os.path.dirname(reset_lcd)\n\n        if self.on_fail and not success:\n            self.on_fail(result)\n        if self.on_complete and success:\n            sublime.set_timeout(self.on_complete, 1)\n        self.result = result\n        if success:\n            self.failed = False\n        return\n\n\nclass SftpWritePanelCommand(sublime_plugin.TextCommand):\n\n    def run(self, edit):\n        printer = PanelPrinter.get(self.view.settings().get('window_id'))\n        read_only = self.view.is_read_only()\n        if read_only:\n            self.view.set_read_only(False)\n        keys_to_erase = []\n        for key in list(printer.queue):\n            while len(printer.strings[key]):\n                string = printer.strings[key].pop(0)\n                if string is None:\n                    self.view.erase_regions(key)\n                    keys_to_erase.append(key)\n                    continue\n                if key == 'sublime_sftp':\n                    point = self.view.size()\n                else:\n                    regions = self.view.get_regions(key)\n                    if not len(regions):\n                        point = self.view.size()\n                    else:\n                        region = regions[0]\n                        point = region.b + 1\n                    if point == 0 and string[0] == '\\n':\n                        string = string[1:]\n                    self.view.insert(edit, point, string)\n                if key != 'sublime_sftp':\n                    point = point + len(string) - 1\n                    region = sublime.Region(point, point)\n                    self.view.add_regions(key, [region], '')\n                    continue\n\n        for key in keys_to_erase:\n            if key in printer.strings:\n                del printer.strings[key]\n            try:\n                printer.queue.remove(key)\n            except ValueError:\n                pass\n\n        if read_only:\n            self.view.set_read_only(True)\n        return\n\n\nclass SftpInsertViewCommand(sublime_plugin.TextCommand):\n\n    def run(self, edit, position=0, string=''):\n        self.view.insert(edit, position, string)\n\n\nclass SftpReplaceViewCommand(sublime_plugin.TextCommand):\n\n    def run(self, edit, start=0, end=0, string=''):\n        self.view.replace(edit, sublime.Region(start, end), string)\n\n\nclass SftpShowPanelCommand(sublime_plugin.WindowCommand, SftpCommand):\n\n    def run(self):\n        PanelPrinter.get(self.window.id()).show(True)\n\n\nclass SftpCreateServerCommand(sublime_plugin.WindowCommand):\n\n    def run(self):\n        config_dir = get_server_config_folder()\n        self.window.run_command('new_file_at', {'dirs': [config_dir]})\n        view_settings = self.window.active_view().settings()\n        view_settings.set('syntax', 'Packages/JavaScript/JSON.tmLanguage')\n        view_settings.set('sftp_new_server', True)\n        snippet = get_default_config(remove_settings=[\n         'save_before_upload',\n         'upload_on_save',\n         'confirm_sync',\n         'ignore_regex',\n         'ignore_regexes',\n         'confirm_overwrite_newer',\n         'sync_skip_deletes',\n         'confirm_downloads'], force_settings={'sync_down_on_open': True})\n        self.window.active_view().run_command('insert_snippet', {'contents': snippet})\n\n\nclass SftpLastServerCommand(sublime_plugin.WindowCommand):\n\n    def run(self):\n        name = BrowsePathThread.get_last()\n        if not name:\n            return\n        self.window.run_command('sftp_browse_server', {'name': name})\n\n\nclass SftpBrowseServerCommand(sublime_plugin.WindowCommand):\n\n    def run(self, name=None):\n        config_dir = get_server_config_folder()\n        self.config_dir = config_dir\n        servers = []\n        for filename in os.listdir(config_dir):\n            if filename in ('.DS_Store', 'Thumbs.db', 'desktop.ini'):\n                continue\n            if os.path.isdir(os.path.join(config_dir, filename)):\n                continue\n            config = prepare_server_config(filename)\n            if config:\n                servers.append(config)\n                continue\n\n        self.servers = servers\n        choices = [['  ' + r['name'], '  ' + r['desc'] + ' ' + r.get('remote_path', '')] for r in servers]\n        choices.insert(0, ['Add New Server…', 'Set up a new SFTP or FTP server to browse'])\n        self.window_id = self.window.id()\n        self.printer = PanelPrinter.get(self.window_id)\n        names = [s['name'] for s in servers]\n        if name and name in names:\n            self.on_done(names.index(name) + 1)\n            return\n        show_qp(self.window, choices, self.on_done)\n\n    def on_done(self, index):\n        if index == -1:\n            return\n        else:\n            if index == 0:\n                self.window.run_command('sftp_create_server')\n                return\n            else:\n                index -= 1\n                raw_config = self.servers[index]\n                if raw_config is None:\n                    return\n                tmp_dir = setup_tmp_dir(raw_config)\n                config = build_config(raw_config, tmp_dir, raw_config['file_path'])\n                return config or None\n            config['is_tmp'] = True\n            config['tmp_dir'] = tmp_dir\n            debug_print('SFTP: Starting Browse Path Thread from List', 2)\n            BrowsePathThread(config, self.printer, self.window_id, self.window, None).start()\n            return\n\n\nclass SftpEditServerCommand(sublime_plugin.WindowCommand):\n\n    def run(self):\n        config_dir = get_server_config_folder()\n        self.config_dir = config_dir\n        servers = []\n        for filename in os.listdir(config_dir):\n            if filename in ('.DS_Store', 'Thumbs.db', 'desktop.ini'):\n                continue\n            if os.path.isdir(os.path.join(config_dir, filename)):\n                continue\n            config = prepare_server_config(filename)\n            if config:\n                servers.append(config)\n                continue\n\n        self.servers = servers\n        choices = [['  ' + r['name'], '  ' + r['desc'] + ' ' + r.get('remote_path', '')] for r in servers]\n        show_qp(self.window, choices, self.on_done)\n\n    def on_done(self, index):\n        if index == -1:\n            return\n        remote = self.servers[index]\n        config_path = os.path.join(self.config_dir, remote['name'])\n\n        def open_file():\n            self.window.run_command('open_file', {'file': fix_windows_path(config_path)})\n            self.window.active_view().settings().set('syntax', 'Packages/JavaScript/JSON.tmLanguage')\n\n        sublime.set_timeout(open_file, 1)\n\n\nclass SftpDeleteServerCommand(sublime_plugin.WindowCommand):\n\n    def run(self):\n        config_dir = get_server_config_folder()\n        self.config_dir = config_dir\n        servers = []\n        for filename in os.listdir(config_dir):\n            if filename in ('.DS_Store', 'Thumbs.db', 'desktop.ini'):\n                continue\n            if os.path.isdir(os.path.join(config_dir, filename)):\n                continue\n            config = prepare_server_config(filename)\n            if config:\n                servers.append(config)\n                continue\n\n        self.servers = servers\n        choices = [['  ' + r['name'], '  ' + r['desc'] + ' ' + r.get('remote_path', '')] for r in servers]\n        show_qp(self.window, choices, self.on_done)\n\n    def on_done(self, index):\n        if index == -1:\n            return\n        remote = self.servers[index]\n        self.config_path = os.path.join(self.config_dir, remote['name'])\n        choices = [\n         [\n          'Yes', 'Delete %s server' % remote['name']],\n         [\n          'No', 'Do not delete %s server' % remote['name']]]\n        show_qp(self.window, choices, self.confirm_delete)\n\n    def confirm_delete(self, index):\n        if index == -1 or index == 1:\n            return\n        os.unlink(self.config_path)\n\n\nclass QuickPanelBrowser(object):\n\n    def cleanup(self):\n        if 'is_tmp' not in self.config:\n            return\n        tmp_dir = dirname(self.config['local_dir'])\n        if os.path.exists(tmp_dir):\n            shutil.rmtree(tmp_dir)\n\n\nclass BrowsePathThread(HookedThread, QuickPanelBrowser):\n    last_name = None\n\n    @classmethod\n    def get_last(cls):\n        return cls.last_name\n\n    def __init__(self, config, printer, window_id, window, remote_path, second_time=False):\n        self.config = config\n        self.printer = printer\n        self.window_id = window_id\n        self.window = window\n        self.remote_path = remote_path\n        super(BrowsePathThread, self).__init__()\n\n    def run(self):\n        BrowsePathThread.last_name = self.config['name']\n        if self.remote_path is None:\n            pwd_thread = SftpThread(self.window_id, self.config, None, 'cwd', hide=False)\n            pwd_thread.start()\n            pwd_thread.join()\n            if pwd_thread.failed:\n                sublime.set_timeout(self.printer.show, 1)\n                self.cleanup()\n                return\n            self.remote_path = pwd_thread.result\n        reset_lcd = None\n        if self.config.get('is_tmp'):\n            reset_lcd = dirname(dirname(self.config['local_dir']))\n        list_dir_thread = SftpThread(self.window_id, self.config, self.remote_path, 'list', reset_lcd=reset_lcd, hide=False, skip_ignore=True, skip_symlinks=False)\n        list_dir_thread.start()\n        list_dir_thread.join()\n        if list_dir_thread.failed and list_dir_thread.result in ('File not found',\n                                                                 'Folder not found',\n                                                                 'Permission denied'):\n            debug_print('SFTP: Starting Browse Thread after Error', 2)\n            BrowsePathThread(self.config, self.printer, self.window_id, self.window, dirname(self.remote_path), second_time=True).start()\n            return\n        else:\n            if list_dir_thread.failed:\n                sublime.set_timeout(self.printer.show, 1)\n                self.cleanup()\n                return\n            self.files = []\n            self.entries = []\n            listing = [p[0] for p in list_dir_thread.result if is_dir(p[0])]\n            listing.extend([p[0] for p in list_dir_thread.result if not is_dir(p[0]) and p[0] != '.'])\n            if list_dir_thread.result:\n                self.files.extend([p for p in listing])\n                self.entries.extend(['    ' + p for p in listing if is_dir(p)])\n                self.entries.extend(['    ' + p for p in listing if not is_dir(p)])\n            self.files.insert(0, '')\n            self.entries.insert(0, '' + self.config['host'] + ':' + self.remote_path)\n            if not is_root(self.remote_path):\n                self.files.insert(1, '..')\n                self.entries.insert(1, 'Up a folder')\n            self.files.insert(1, '.')\n            self.entries.insert(1, 'Folder actions')\n            self.existing_files = [\n             '.', '..']\n            if list_dir_thread.result:\n                self.existing_files.extend([p[0].rstrip('/\\\\') for p in list_dir_thread.result])\n            sublime.set_timeout(self.show_files, 1)\n            return\n\n    def show_files(self):\n        show_qp(self.window, self.entries, self.show_files_action)\n\n    def custom_path(self):\n        self.window.show_input_panel('Browse to', self.remote_path, self.browse_to, None, self.show_files)\n        return\n\n    def browse_to(self, input):\n        if len(input) == 0:\n            input = '/'\n        input = canonicalize(input, 'remote')\n        debug_print('SFTP: Starting Custom Browse Path Thread', 2)\n        BrowsePathThread(self.config, self.printer, self.window_id, self.window, input).start()\n\n    def show_files_action(self, index):\n        if index == -1:\n            self.cleanup()\n            return\n        else:\n            selected = self.files[index]\n            new_path = None\n            if selected == '':\n                self.custom_path()\n                return\n            if selected == '..':\n                new_path = dirname(self.remote_path)\n            else:\n                if selected == '.':\n                    self.selected_path = self.remote_path\n                    self.modify_dir()\n                    return\n                if not is_dir(selected):\n                    self.selected_path = os.path.join(self.remote_path, selected)\n                    self.modify_file()\n                    return\n                new_path = os.path.join(self.remote_path, selected)\n            debug_print('SFTP: Starting Browse Sub-path Thread', 2)\n            BrowsePathThread(self.config, self.printer, self.window_id, self.window, new_path).start()\n            return\n\n    def modify_dir(self):\n        actions = [\n         '' + self.config['host'] + ':' + self.selected_path,\n         'Back to list',\n         'New file',\n         'New folder',\n         'Rename',\n         'Chmod',\n         'Delete']\n        if not self.config.get('is_tmp'):\n            actions.insert(4, 'Download')\n        show_qp(self.window, actions, self.modify_dir_action)\n\n    def modify_dir_action(self, index):\n        if index == -1:\n            self.cleanup()\n            return\n        else:\n            if index == 0 or index == 1:\n                self.show_files()\n                return\n            is_tmp = self.config.get('is_tmp')\n            if index == 2:\n                self.window.show_input_panel('New file name', '', self.new_file, None, self.modify_dir)\n            if index == 3:\n                self.window.show_input_panel('New folder name', '', self.new_folder, None, self.modify_dir)\n            if index == 4 and not is_tmp:\n                debug_print('SFTP: Starting Download Folder Thread', 2)\n                DownloadPathThread(self.config, self.printer, self.window_id, self.window, self.selected_path).start()\n            if not is_tmp and index == 5 or is_tmp and index == 4:\n                self.window.show_input_panel('New name', os.path.basename(self.selected_path.rstrip('/\\\\')), self.rename_folder, None, self.modify_dir)\n            if not is_tmp and index == 6 or is_tmp and index == 5:\n                self.window.show_input_panel('New permissions', '755', self.chmod_folder, None, self.modify_dir)\n            if not is_tmp and index == 7 or is_tmp and index == 6:\n                name = canonicalize(os.path.basename(self.selected_path.rstrip('/\\\\')), 'remote')\n                choices = [\n                 [\n                  'Yes', 'Delete %s and all children' % name],\n                 [\n                  'No', 'Do not delete %s' % name]]\n                show_qp(self.window, choices, self.confirm_delete_dir)\n            return\n\n    def new_file(self, new_name):\n        if new_name.find('\\\\') != -1 or new_name.find('/') != -1:\n\n            def try_again_slash():\n                sublime.error_message('Sublime SFTP\\n\\nFile name may not contain slashes')\n                self.window.show_input_panel('New file name', '', self.new_file, None, self.modify_dir)\n                return\n\n            sublime.set_timeout(try_again_slash, 1)\n            return\n        if new_name in self.existing_files:\n\n            def try_again_existing():\n                sublime.error_message('Sublime SFTP\\n\\nA file or folder with that name specified already exists')\n                self.window.show_input_panel('New file name', '', self.new_file, None, self.modify_dir)\n                return\n\n            sublime.set_timeout(try_again_existing, 1)\n            return\n        new_path = os.path.join(self.selected_path, new_name)\n        debug_print('SFTP: Starting New File Thread', 2)\n        NewFileThread(self.config, self.printer, self.window_id, self.window, new_path).start()\n\n    def new_folder(self, new_name):\n        if new_name.find('\\\\') != -1 or new_name.find('/') != -1:\n\n            def try_again_slash():\n                sublime.error_message('Sublime SFTP\\n\\nFolder name may not contain slashes')\n                self.window.show_input_panel('New folder name', '', self.new_folder, None, self.modify_dir)\n                return\n\n            sublime.set_timeout(try_again_slash, 1)\n            return\n        if new_name in self.existing_files:\n\n            def try_again_existing():\n                sublime.error_message('Sublime SFTP\\n\\nA file or folder with that name specified already exists')\n                self.window.show_input_panel('New folder name', '', self.new_folder, None, self.modify_dir)\n                return\n\n            sublime.set_timeout(try_again_existing, 1)\n            return\n        new_path = os.path.join(self.selected_path, new_name)\n        debug_print('SFTP: Starting New Folder Thread', 2)\n        NewFolderThread(self.config, self.printer, self.window_id, self.window, new_path).start()\n\n    def rename_folder(self, new_name):\n        if new_name == os.path.basename(self.selected_path.rstrip('\\\\/')):\n            self.cleanup()\n            return\n        if new_name.find('\\\\') != -1 or new_name.find('/') != -1:\n\n            def try_again():\n                sublime.error_message('Sublime SFTP\\n\\nFolder name may not contain slashes')\n                self.window.show_input_panel('New name', os.path.basename(self.selected_path.rstrip('/\\\\')), self.rename_folder, None, self.modify_dir)\n                return\n\n            sublime.set_timeout(try_again, 1)\n            return\n        new_path = os.path.join(dirname(self.selected_path), new_name)\n        new_path = canonicalize(new_path, 'remote')\n        debug_print('SFTP: Starting Rename Folder Thread', 2)\n        RenamePathThread(self.config, self.printer, self.window_id, self.window, self.selected_path, new_path).start()\n\n    def chmod_folder(self, mode):\n        debug_print('SFTP: Starting Chmod Folder Thread', 2)\n        ChmodPathThread(self.config, self.printer, self.window_id, self.window, self.selected_path, mode).start()\n\n    def confirm_delete_dir(self, index):\n        if index == -1 or index == 1:\n            self.modify_dir()\n            return\n        DeletePathThread(self.config, self.printer, self.window_id, self.window, self.selected_path).start()\n\n    def modify_file(self):\n        actions = [\n         '' + self.config['host'] + ':' + self.selected_path,\n         'Back to list',\n         'Edit',\n         'Rename',\n         'Chmod',\n         'Delete']\n        if not self.config.get('is_tmp'):\n            actions[2] += ' (remote version)'\n            actions.insert(3, 'Download')\n        show_qp(self.window, actions, self.modify_file_action)\n\n    def modify_file_action(self, index):\n        if index == -1:\n            self.cleanup()\n            return\n        else:\n            is_tmp = self.config.get('is_tmp')\n            if index == 0 or index == 1:\n                self.show_files()\n                return\n            if index == 2:\n                debug_print('SFTP: Starting Edit File Thread', 2)\n                EditFileThread(self.config, self.printer, self.window_id, self.window, self.selected_path).start()\n                return\n            if index == 3 and not is_tmp:\n                debug_print('SFTP: Starting Download File Thread', 2)\n                DownloadPathThread(self.config, self.printer, self.window_id, self.window, self.selected_path).start()\n            if not is_tmp and index == 4 or is_tmp and index == 3:\n                self.window.show_input_panel('New name', os.path.basename(self.selected_path.rstrip('/\\\\')), self.rename_file, None, self.modify_file)\n            if not is_tmp and index == 5 or is_tmp and index == 4:\n                self.window.show_input_panel('New permissions', '644', self.chmod_file, None, self.modify_file)\n            if not is_tmp and index == 6 or is_tmp and index == 5:\n                name = os.path.basename(self.selected_path)\n                choices = [\n                 [\n                  'Yes', 'Delete %s' % name],\n                 [\n                  'No', 'Do not delete %s' % name]]\n                show_qp(self.window, choices, self.confirm_delete_file)\n            return\n\n    def rename_file(self, new_name):\n        if new_name == os.path.basename(self.selected_path.rstrip('\\\\/')):\n            self.cleanup()\n            return\n        if new_name.find('\\\\') != -1 or new_name.find('/') != -1:\n\n            def try_again():\n                sublime.error_message('Sublime SFTP\\n\\nFile name may not contain slashes')\n                self.window.show_input_panel('New name', os.path.basename(self.selected_path.rstrip('/\\\\')), self.rename_path, None, self.modify_file)\n                return\n\n            sublime.set_timeout(try_again, 1)\n            return\n        new_path = os.path.join(dirname(self.selected_path), new_name)\n        debug_print('SFTP: Starting Rename File Thread', 2)\n        RenamePathThread(self.config, self.printer, self.window_id, self.window, self.selected_path, new_path).start()\n\n    def chmod_file(self, mode):\n        debug_print('SFTP: Starting Chmod File Thread', 2)\n        ChmodPathThread(self.config, self.printer, self.window_id, self.window, self.selected_path, mode).start()\n\n    def confirm_delete_file(self, index):\n        if index == -1 or index == 1:\n            self.modify_file()\n            return\n        debug_print('SFTP: Starting Delete File Thread', 2)\n        DeletePathThread(self.config, self.printer, self.window_id, self.window, self.selected_path).start()\n\n\nclass DownloadPathThread(HookedThread):\n\n    def __init__(self, config, printer, window_id, window, remote_path, on_complete=None):\n        self.config = config\n        self.printer = printer\n        self.window_id = window_id\n        self.window = window\n        self.remote_path = remote_path\n        self.on_complete = on_complete\n        super(DownloadPathThread, self).__init__()\n\n    def run(self):\n        sublime.set_timeout(self.printer.show, 1)\n        if not is_dir(self.remote_path):\n            download_thread = SftpThread(self.window_id, self.config, self.remote_path, 'get', should_join=False)\n            download_thread.start()\n            download_thread.join()\n            local_path = remote_to_local(self.remote_path, self.config['path_map'])\n            if not download_thread.failed:\n\n                def open_file():\n                    self.window.run_command('open_file', {'file': fix_windows_path(local_path)})\n                    if self.on_complete:\n                        self.on_complete()\n\n                sublime.set_timeout(open_file, 1)\n            else:\n                BrowsePathThread(self.config, self.printer, self.window_id, self.window, dirname(self.remote_path)).start()\n        else:\n            download_thread = DownloadFolderThread(self.window_id, self.config, self.remote_path)\n            download_thread.start()\n            download_thread.join()\n            if download_thread.error:\n                sublime.set_timeout(self.printer.show, 1)\n            BrowsePathThread(self.config, self.printer, self.window_id, self.window, self.remote_path).start()\n\n\nclass EditFileThread(HookedThread):\n\n    def __init__(self, config, printer, window_id, window, remote_path):\n        self.config = config\n        self.printer = printer\n        self.window_id = window_id\n        self.window = window\n        self.remote_path = remote_path\n        self.local_path = None\n        if not config.get('tmp_dir'):\n            self.local_path = remote_to_local(remote_path, config.get('path_map'))\n            raw_config, config_file = load_config(self.config['local_dir'])\n            tmp_dir = setup_tmp_dir(raw_config)\n            raw_config, config_file = load_config(tmp_dir)\n            new_config = build_config(raw_config, tmp_dir, config_file)\n            new_config['tmp_dir'] = tmp_dir\n            self.config = new_config\n        super(EditFileThread, self).__init__()\n        return\n\n    def run(self):\n        config = self.config.copy()\n        config['path_map'] = {config['tmp_dir']: config['remote_dir']}\n        local_path = remote_to_local(self.remote_path, config['path_map'])\n        sublime.set_timeout(self.printer.show, 1)\n        download_thread = SftpThread(self.window_id, config, self.remote_path, 'get', should_join=False, reset_lcd=dirname(dirname(config['local_dir'])))\n        download_thread.start()\n        download_thread.join()\n        if not download_thread.failed:\n\n            def open_file():\n                self.window.run_command('open_file', {'file': fix_windows_path(local_path)})\n                view = self.window.active_view()\n                if self.local_path:\n                    view.settings().set('local_path', self.local_path)\n                view.settings().set('remote_loading', True)\n                view.settings().set('synced', True)\n                view.settings().set('is_remote', True)\n                view.settings().set('tmp_dir', self.config['tmp_dir'])\n\n            sublime.set_timeout(open_file, 1)\n        else:\n            BrowsePathThread(self.config, self.printer, self.window_id, self.window, dirname(self.remote_path)).start()\n\n\nclass NewFileThread(HookedThread):\n\n    def __init__(self, config, printer, window_id, window, remote_path):\n        self.config = config\n        self.printer = printer\n        self.window_id = window_id\n        self.window = window\n        self.remote_path = remote_path\n        super(NewFileThread, self).__init__()\n\n    def run(self):\n        local_path = remote_to_local(self.remote_path, self.config['path_map'])\n        if not os.path.exists(dirname(local_path)):\n            os.makedirs(dirname(local_path))\n        open(local_path, 'a').close()\n        sublime.set_timeout(self.printer.show, 1)\n        reset_lcd = None\n        if self.config.get('is_tmp'):\n            reset_lcd = dirname(dirname(self.config['local_dir']))\n        mv_thread = SftpThread(self.window_id, self.config, local_path, 'put', reset_lcd=reset_lcd)\n        mv_thread.start()\n        mv_thread.join()\n        if not mv_thread.failed:\n\n            def status():\n                sublime.status_message('%s successfully created' % path_type(self.remote_path, True))\n                self.window.run_command('open_file', {'file': fix_windows_path(local_path)})\n                view = self.window.active_view()\n                if 'is_tmp' in self.config:\n                    view.settings().set('is_remote', True)\n                    view.settings().set('tmp_dir', self.config['local_dir'])\n\n            sublime.set_timeout(status, 1)\n        else:\n            BrowsePathThread(self.config, self.printer, self.window_id, self.window, dirname(self.remote_path)).start()\n        return\n\n\nclass NewFolderThread(HookedThread):\n\n    def __init__(self, config, printer, window_id, window, remote_path):\n        self.config = config\n        self.printer = printer\n        self.window_id = window_id\n        self.window = window\n        self.remote_path = remote_path\n        super(NewFolderThread, self).__init__()\n\n    def run(self):\n        local_path = remote_to_local(self.remote_path, self.config['path_map'])\n        os.makedirs(local_path)\n        sublime.set_timeout(self.printer.show, 1)\n        reset_lcd = None\n        if self.config.get('is_tmp'):\n            reset_lcd = dirname(dirname(self.config['local_dir']))\n        mv_thread = SftpThread(self.window_id, self.config, local_path, 'put', reset_lcd=reset_lcd)\n        mv_thread.start()\n        mv_thread.join()\n        if not mv_thread.failed:\n\n            def status():\n                sublime.status_message('Folder successfully created')\n\n            sublime.set_timeout(status, 1)\n        BrowsePathThread(self.config, self.printer, self.window_id, self.window, dirname(self.remote_path)).start()\n        return\n\n\nclass ChmodPathThread(HookedThread):\n\n    def __init__(self, config, printer, window_id, window, remote_path, mode):\n        self.config = config\n        self.printer = printer\n        self.window_id = window_id\n        self.window = window\n        self.remote_path = remote_path\n        self.mode = mode\n        super(ChmodPathThread, self).__init__()\n\n    def run(self):\n        sublime.set_timeout(self.printer.show, 1)\n        reset_lcd = None\n        if self.config.get('is_tmp'):\n            reset_lcd = dirname(dirname(self.config['local_dir']))\n        chmod_thread = SftpThread(self.window_id, self.config, self.remote_path, 'chmod', reset_lcd=reset_lcd, mode=self.mode)\n        chmod_thread.start()\n        chmod_thread.join()\n        if not chmod_thread.failed:\n\n            def status():\n                sublime.status_message('%s successfully chmodded' % path_type(self.remote_path, True))\n\n            sublime.set_timeout(status, 1)\n        BrowsePathThread(self.config, self.printer, self.window_id, self.window, dirname(self.remote_path)).start()\n        return\n\n\nclass RenamePathThread(HookedThread):\n\n    def __init__(self, config, printer, window_id, window, remote_path, new_remote_path):\n        self.config = config\n        self.printer = printer\n        self.window_id = window_id\n        self.window = window\n        self.remote_path = remote_path\n        self.new_remote_path = new_remote_path\n        super(RenamePathThread, self).__init__()\n\n    def run(self):\n        sublime.set_timeout(self.printer.show, 1)\n        reset_lcd = None\n        if self.config.get('is_tmp'):\n            reset_lcd = dirname(dirname(self.config['local_dir']))\n        mv_thread = SftpThread(self.window_id, self.config, [\n         self.remote_path, self.new_remote_path], 'mv', reset_lcd=reset_lcd)\n        mv_thread.start()\n        mv_thread.join()\n        if not mv_thread.failed:\n\n            def status():\n                sublime.status_message('%s successfully renamed' % path_type(self.remote_path, True))\n\n            sublime.set_timeout(status, 1)\n        BrowsePathThread(self.config, self.printer, self.window_id, self.window, dirname(self.remote_path)).start()\n        return\n\n\nclass DeletePathThread(HookedThread):\n\n    def __init__(self, config, printer, window_id, window, remote_path):\n        self.config = config\n        self.printer = printer\n        self.window_id = window_id\n        self.window = window\n        self.remote_path = remote_path\n        super(DeletePathThread, self).__init__()\n\n    def run(self):\n        if is_dir(self.remote_path):\n            reset_lcd = None\n            if self.config.get('is_tmp'):\n                reset_lcd = dirname(dirname(self.config['local_dir']))\n            list_thread = SftpThread(self.window_id, self.config, self.remote_path, 'listr', should_join=False, reset_lcd=reset_lcd, hide=False, skip_symlinks='file')\n            list_thread.start()\n            list_thread.join()\n            if list_thread.failed or not list_thread.result:\n                return\n            remote_paths = [p[0] for p in list_thread.result[::-1]]\n        else:\n            remote_paths = self.remote_path\n        sublime.set_timeout(self.printer.show, 1)\n        reset_lcd = None\n        if self.config.get('is_tmp'):\n            reset_lcd = dirname(dirname(self.config['local_dir']))\n        rm_thread = SftpThread(self.window_id, self.config, remote_paths, 'rm', reset_lcd=reset_lcd)\n        rm_thread.start()\n        rm_thread.join()\n        if not rm_thread.failed:\n\n            def status():\n                sublime.status_message('%s successfully deleted' % path_type(self.remote_path, True))\n\n            sublime.set_timeout(status, 1)\n        BrowsePathThread(self.config, self.printer, self.window_id, self.window, dirname(self.remote_path)).start()\n        return\n\n\nclass SftpBrowseCommand(sublime_plugin.WindowCommand, SftpCommand):\n\n    def run(self, paths=None, group=None, index=None, reset_lcd=None):\n        config = self.get_config(paths)\n        if not config:\n            return\n        else:\n            if paths is None:\n                active_view = self.window.active_view()\n                if active_view and active_view.settings().get('is_remote') and config.get('is_server'):\n                    self.window.run_command('sftp_browse_server', {'name': config.get('name')})\n                    return\n            printer = PanelPrinter.get(self.window.id())\n            path = self.get_path(paths)\n            if path is None:\n                return\n            if not os.path.isdir(path):\n                path = os.path.dirname(path)\n            path = canonicalize(path, 'local')\n            remote_path = local_to_remote(path, config['path_map'])\n            debug_print('SFTP: Starting Browse Thread', 2)\n            BrowsePathThread(config, printer, self.window.id(), self.window, remote_path).start()\n            return\n\n    def is_visible(self, paths=None):\n        path = self.get_path(paths)\n        if not path:\n            return False\n        return self.has_config(path)\n\n\nclass SftpUploadFileCommand(sublime_plugin.WindowCommand, SftpCommand):\n\n    def run(self, paths=None, group=None, index=None, reset_lcd=None):\n        if paths is None and group is not None and index is not None:\n            selected_view = get_view_by_group_index(self.window, group, index)\n            paths = [selected_view.file_name()]\n        config = self.get_config(paths)\n        if not config:\n            return\n        files = self.get_path(paths, True)\n        filtered_files = []\n\n        def filter_file(file_):\n            if os.path.exists(file_):\n                filtered_files.append(file_)\n            else:\n                debug_print('SFTP: Skipping File Not Present on Disk', 2)\n\n        if isinstance(files, list):\n            for file_ in files:\n                filter_file(file_)\n\n        else:\n            filter_file(files)\n            if filtered_files:\n                filtered_files = filtered_files[0]\n            files = filtered_files\n            if not files:\n                sublime.error_message('Sublime SFTP\\n\\nUnable to upload file since it is not present on disk')\n                return\n            else:\n                if config['save_before_upload']:\n                    self.save_files(files)\n                printer = PanelPrinter.get(self.window.id())\n                printer.show()\n                if config['confirm_overwrite_newer']:\n                    debug_print('SFTP: Starting Confirm Overwrite File Thread', 2)\n                    ConfirmOverwriteFileThread(self.window, printer, config, files, reset_lcd=reset_lcd).start()\n                else:\n                    debug_print('SFTP: Starting Upload File Thread', 2)\n                    SftpThread(self.window.id(), config, files, 'put', reset_lcd=reset_lcd).start()\n                return\n\n    def is_visible(self, paths=None):\n        path = self.get_path(paths)\n        if not path or os.path.isdir(path):\n            return False\n        return self.has_config(path)\n\n\nclass ConfirmOverwriteFileThread(HookedThread, SyncThread):\n\n    def __init__(self, window, printer, config, files, reset_lcd):\n        self.window = window\n        self.window_id = window.id()\n        self.printer = printer\n        self.config = config\n        if not isinstance(files, list):\n            files = [\n             files]\n        self.files = files\n        self.reset_lcd = reset_lcd\n        super(ConfirmOverwriteFileThread, self).__init__()\n\n    def run(self):\n        last_thread = ThreadTracker.get_last_added(self.window_id)\n        ThreadTracker.add(self)\n        if last_thread is not None:\n            last_thread.join()\n        path_map = self.config['path_map']\n        for path in self.files:\n            remote_path = local_to_remote(path, path_map, self.config['remote_encoding'])\n            nonlocal_ = {'progress': None}\n\n            def on_connect():\n                nonlocal_['progress'] = ProgressThread(self.printer, '\\nChecking modification date of \"%s\"' % remote_path)\n\n            def on_fail(e):\n                if not nonlocal_['progress']:\n                    return\n                nonlocal_['progress'].stop('failure (%s)' % str(e))\n                nonlocal_['progress'].join()\n\n            dir = canonicalize(dirname(path), 'local')\n            remote_dir = local_to_remote(dir, path_map, self.config['remote_encoding'])\n            list_dir_thread = SftpThread(self.window_id, self.config, remote_dir, 'list', should_join=False, hide=False, on_connect=on_connect, on_fail=on_fail, skip_symlinks='file')\n            list_dir_thread.start()\n            list_dir_thread.join()\n\n            def upload_file():\n                debug_print('SFTP: Starting Confirmed Upload File Thread', 2)\n                put_thread = SftpThread(self.window_id, self.config, path, 'put', should_join=False, hide=False, reset_lcd=self.reset_lcd)\n                put_thread.start()\n                put_thread.join()\n\n            if list_dir_thread.failed and list_dir_thread.result in ('File not found',\n                                                                     'Folder not found'):\n                upload_file()\n                continue\n            if list_dir_thread.failed:\n                return\n            if nonlocal_['progress']:\n                nonlocal_['progress'].stop('success')\n                nonlocal_['progress'].join()\n            remote_paths = list_dir_thread.result\n            if list_dir_thread.failed or remote_paths is None:\n                remote_paths = []\n            remote_dict = dict(remote_paths)\n            remote_mod_time = remote_dict.get(os.path.basename(remote_path), None)\n            local_mod_time = int(os.lstat(path)[8])\n            if not remote_mod_time or local_mod_time >= remote_mod_time:\n                upload_file()\n                continue\n            nonlocal_ = {'confirmed': None}\n\n            def on_confirm():\n                nonlocal_['confirmed'] = True\n\n            def on_reject():\n                nonlocal_['confirmed'] = False\n\n            local_time = self.make_time(local_mod_time)\n            remote_time = self.make_time(remote_mod_time)\n            operations = [\n             'Upload local \"%s\" (%s) over remote \"%s\" [%s vs. %s]' % (\n              self.strip(path, dir, 'local'),\n              time_diff(local_mod_time, remote_mod_time),\n              self.strip(remote_path, remote_dir, 'remote'),\n              local_time, remote_time)]\n            self.confirm(operations, on_confirm, on_reject)\n            while True:\n                if nonlocal_['confirmed'] is not None:\n                    break\n                time.sleep(0.01)\n\n            if nonlocal_['confirmed']:\n                upload_file()\n                continue\n\n        def do_hide():\n            self.printer.hide()\n\n        sublime.set_timeout(do_hide, 1)\n        return\n\n\nclass SftpMonitorFileCommand(sublime_plugin.WindowCommand, SftpCommand):\n\n    def run(self, paths=None):\n        config = self.get_config(paths)\n        if not config:\n            return\n        printer = PanelPrinter.get(self.window.id())\n        path = self.get_path(paths)\n        if not path:\n            return\n        view = self.window.active_view()\n        if view.id() not in [v.id for v in self.window.views()]:\n            file_name = fix_windows_path(view.file_name())\n            self.window.run_command('open_file', {'file': file_name})\n        if not view.get_status('sftp_monitor'):\n            debug_print('SFTP: Starting File Monitoring', 2)\n            sftp_settings = sublime.load_settings('SFTP.sublime-settings')\n            frequency = sftp_settings.get('monitoring_frequency', 200)\n            frequency = float(frequency) / 1000.0\n            delay = sftp_settings.get('monitoring_upload_delay', 500)\n            delay = float(delay) / 1000.0\n            view.set_status('sftp_monitor', 'SFTP: Monitoring')\n            MonitorFileThread(self.window, view, printer, config, path, frequency, delay).start()\n        else:\n            view.erase_status('sftp_monitor')\n\n    def is_visible(self, paths=None):\n        if paths is None:\n            active_view = self.window.active_view()\n            if active_view and active_view.settings().get('is_remote'):\n                return False\n        path = self.get_path(paths)\n        if not path or os.path.isdir(path):\n            return False\n        else:\n            return self.has_config(path)\n\n\nclass MonitorFileThread(HookedThread):\n\n    def __init__(self, window, view, printer, config, path, frequency, delay):\n        self.window = window\n        self.window_id = window.id()\n        self.view = view\n        self.printer = printer\n        self.config = config\n        self.path = path\n        self.frequency = frequency\n        self.delay = delay\n        super(MonitorFileThread, self).__init__()\n\n    def run(self):\n        nonlocal_ = {'cont': True}\n        try:\n            uploaded_mod_time = int(os.lstat(self.path)[8])\n        except OSError as e:\n            debug_print('SFTP: Monitoring Error - %s' % str(e), 2)\n            nonlocal_['cont'] = False\n\n        num = 0\n        while nonlocal_['cont']:\n            try:\n                mod_time = int(os.lstat(self.path)[8])\n            except OSError as e:\n                debug_print('SFTP: Monitoring Error - %s' % str(e), 2)\n                break\n\n            if mod_time > uploaded_mod_time:\n                time.sleep(self.delay)\n\n                def show():\n                    self.printer.show()\n\n                sublime.set_timeout(show, 1)\n                debug_print('SFTP: Starting Monitored Upload File Thread', 2)\n                SftpThread(self.window_id, self.config, self.path, 'put').start()\n                uploaded_mod_time = mod_time\n            num = (num + 1) % 5\n            if num == 4:\n\n                def check_view():\n                    if self.view is None or not self.view.get_status('sftp_monitor'):\n                        nonlocal_['cont'] = False\n                    return\n\n                sublime.set_timeout(check_view, 1)\n            time.sleep(self.frequency)\n\n        def stop_monitoring():\n            debug_print('SFTP: Stoping File Monitoring', 2)\n            self.view.erase_status('sftp_monitor')\n\n        sublime.set_timeout(stop_monitoring, 1)\n\n\nclass SftpUploadOpenFilesCommand(sublime_plugin.WindowCommand, SftpCommand):\n\n    def run(self, paths=None):\n        debug_print('SFTP: Starting Upload Open Files Command', 2)\n        for view in self.window.views():\n            path = view.file_name()\n            if not path:\n                debug_print('SFTP: Skipping View Without File Name', 2)\n                continue\n            if not os.path.exists(path):\n                debug_print('SFTP: Skipping File Not Present on Disk', 2)\n                continue\n            paths = [\n             path]\n            if not self.has_config(path):\n                debug_print('SFTP: Skipping View Without Remote', 2)\n                continue\n            config = self.get_config(paths)\n            if not config:\n                continue\n            PanelPrinter.get(self.window.id()).show()\n            files = self.get_path(paths, True)\n            if config['save_before_upload']:\n                self.save_files(files)\n            debug_print('SFTP: Starting Upload File Thread', 2)\n            SftpThread(self.window.id(), config, files, 'put').start()\n\n    def is_visible(self, paths=None):\n        if paths is None:\n            active_view = self.window.active_view()\n            if active_view and active_view.settings().get('is_remote'):\n                return False\n        path = self.get_path(paths)\n        if not path or os.path.isdir(path):\n            return False\n        else:\n            return self.has_config(path)\n\n\nclass SftpDiffRemoteFileCommand(sublime_plugin.WindowCommand, SftpCommand):\n\n    def run(self, paths=None):\n        config = self.get_config(paths)\n        if not config:\n            return\n        printer = PanelPrinter.get(self.window.id())\n        printer.show()\n        file = self.get_path(paths)\n        remote_file = local_to_remote(file, config['path_map'])\n        local_path = list(config['path_map'].keys())[0]\n        remote_path = config['path_map'][local_path]\n        tmp_dir = os.path.join(tempfile.gettempdir(), 'sublime-sftp-diff-') + str(int(time.time()))\n        if not os.path.exists(tmp_dir):\n            os.makedirs(tmp_dir)\n        config['path_map'] = {tmp_dir: remote_path}\n        tmp_file = remote_to_local(remote_file, config['path_map'])\n        tmp_file_direct_parent = dirname(tmp_file)\n        if not os.path.exists(tmp_file_direct_parent):\n            os.makedirs(tmp_file_direct_parent)\n        debug_print('SFTP: Starting Diff Remote Thread', 2)\n        SftpThread(self.window.id(), config, remote_file, 'get', reset_lcd=dirname(tmp_dir), on_complete=lambda : self.complete(printer, file, remote_file, tmp_dir, tmp_file)).start()\n\n    def complete(self, printer, file, remote_file, tmp_dir, tmp_file):\n        printer.show()\n        progress = ProgressThread(printer, '\\nDiffing \"%s\" with \"%s\"' % (file, remote_file))\n        sftp_settings = sublime.load_settings('SFTP.sublime-settings')\n        if sftp_settings.get('diff_command'):\n            diff_command_args = sftp_settings.get('diff_command')\n            diff_thread = DiffCommandThread(diff_command_args, file, tmp_file, tmp_dir, sftp_settings.get('delete_temp_diff_folder', True))\n            debug_print('SFTP: Starting Diff Command Thread', 2)\n            diff_thread.start()\n            progress.stop('success (external diff launched)')\n            progress.join()\n        else:\n            settings = sublime.load_settings('Base File.sublime-settings')\n            fallback_encoding = settings.get('fallback_encoding')\n            fallback_encoding = re.sub('^[a-zA-Z ]*\\\\((.*)\\\\)$', '\\\\1', fallback_encoding)\n            try:\n                file_lines = codecs.open(file, 'r', 'utf-8').read().splitlines()\n            except UnicodeDecodeError:\n                debug_print('SFTP: Using fallback encoding \"%s\" when reading local file for diff' % fallback_encoding, 2)\n                file_lines = codecs.open(file, 'r', fallback_encoding).read().splitlines()\n\n            try:\n                tmp_file_lines = codecs.open(tmp_file, 'r', 'utf-8').read().splitlines()\n            except UnicodeDecodeError:\n                debug_print('SFTP: Using fallback encoding \"%s\" when reading remote file for diff' % fallback_encoding, 2)\n                tmp_file_lines = codecs.open(tmp_file, 'r', fallback_encoding).read().splitlines()\n\n            file_date = time.ctime(os.stat(file).st_mtime)\n            tmp_file_date = time.ctime(os.stat(tmp_file).st_mtime)\n            diff = difflib.unified_diff(file_lines, tmp_file_lines, file, tmp_file, file_date, tmp_file_date, lineterm='')\n            diff = '\\n'.join([line for line in diff])\n            if diff == '':\n                progress.stop('success (no changes)')\n                printer.reset_hide()\n            else:\n                name = os.path.basename(file)\n                new_view = self.window.new_file()\n                new_view.set_name('(local) ' + name + ' -> (remote) ' + name)\n                new_view.set_scratch(True)\n                new_view.set_syntax_file('Packages/Diff/Diff.tmLanguage')\n                new_view.run_command('sftp_insert_view', {'position': 0,  'string': diff})\n                progress.stop('success')\n            progress.join()\n        if os.path.exists(tmp_dir):\n            try:\n                shutil.rmtree(tmp_dir)\n            except WindowsError:\n                pass\n\n    def is_visible(self, paths=None):\n        if paths is None:\n            active_view = self.window.active_view()\n            if active_view and active_view.settings().get('is_remote'):\n                return False\n        path = self.get_path(paths)\n        if not path or os.path.isdir(path):\n            return False\n        else:\n            return self.has_config(path)\n\n\nclass DiffCommandThread(HookedThread):\n\n    def __init__(self, args, file, tmp_file, tmp_dir, delete_tmp_dir):\n        self.args = args\n        self.file = file\n        self.tmp_file = tmp_file\n        self.tmp_dir = tmp_dir\n        self.delete_tmp_dir = delete_tmp_dir\n        super(DiffCommandThread, self).__init__()\n\n    def run(self):\n        args = []\n        for arg in self.args:\n            if arg == '%1$s':\n                arg = self.file\n            else:\n                if arg == '%2$s':\n                    arg = self.tmp_file\n                args.append(arg)\n\n        proc = subprocess.Popen(args)\n        proc.wait()\n        if self.delete_tmp_dir and os.path.exists(self.tmp_dir):\n            try:\n                shutil.rmtree(self.tmp_dir)\n            except WindowsError:\n                pass\n\n\nclass SftpRenameLocalAndRemotePathsCommand(sublime_plugin.WindowCommand, SftpCommand):\n\n    def run(self, paths=None, files=None, dirs=None):\n        if paths is None and files is not None:\n            paths = files\n        if paths is None and dirs is not None:\n            paths = dirs\n        config = self.get_config(paths)\n        if not config:\n            return\n        else:\n            printer = PanelPrinter.get(self.window.id())\n            path = self.get_path(paths)\n            remote_path = local_to_remote(path, config['path_map'])\n\n            def prompt_new_name():\n                self.window.show_input_panel('New Name', os.path.basename(path.rstrip('/\\\\')), on_done, None, None)\n                return\n\n            def on_done(new_name):\n                if new_name.find('\\\\') != -1 or new_name.find('/') != -1:\n                    sublime.error_message('Sublime SFTP\\n\\n%s name may not contain slashes' % path_type(path))\n                    prompt_new_name()\n                    return\n                new_path = dirname(path) + new_name\n                if os.path.exists(new_path):\n                    sublime.error_message('Sublime SFTP\\n\\nA file or folder with that name specified already exists')\n                    prompt_new_name()\n                    return\n                new_remote_path = dirname(remote_path) + new_name\n                printer.show()\n                RenameLocalAndRemotePathThread(self.window, config, path, new_path, remote_path, new_remote_path).start()\n\n            prompt_new_name()\n            return\n\n    def is_visible(self, paths=None, files=None, dirs=None):\n        if paths is None and files is None and dirs is None:\n            active_view = self.window.active_view()\n            if active_view and active_view.settings().get('is_remote'):\n                return False\n        if dirs == [] or files == []:\n            return False\n        else:\n            if paths is None and files is not None:\n                paths = files\n            if paths is None and dirs is not None:\n                paths = dirs\n            path = self.get_path(paths)\n            if not path:\n                return False\n            return self.has_config(path)\n\n\nclass RenameLocalAndRemotePathThread(HookedThread):\n\n    def __init__(self, window, config, path, new_path, remote_path, new_remote_path):\n        self.window = window\n        self.window_id = window.id()\n        self.config = config\n        self.path = path\n        self.new_path = new_path\n        self.remote_path = remote_path\n        self.new_remote_path = new_remote_path\n        super(RenameLocalAndRemotePathThread, self).__init__()\n\n    def run(self):\n        last_thread = ThreadTracker.get_last_added(self.window_id)\n        ThreadTracker.add(self)\n        if last_thread is not None:\n            last_thread.join()\n        mv_thread = SftpThread(self.window_id, self.config, [\n         self.remote_path, self.new_remote_path], 'mv', should_join=False, reset_lcd=dirname(self.config['local_dir']))\n        mv_thread.start()\n        mv_thread.join()\n        if mv_thread.failed:\n            return\n        else:\n            os.rename(self.path, self.new_path)\n            if int(sublime.version()) < 2178:\n                return\n\n            def do_retarget():\n                view = self.window.find_open_file(self.path)\n                if view:\n                    view.retarget(self.new_path)\n\n            sublime.set_timeout(do_retarget, 1)\n            return\n\n\nclass SftpDeleteLocalAndRemotePathsCommand(sublime_plugin.WindowCommand, SftpCommand):\n\n    def run(self, paths=None, files=None, dirs=None):\n        if paths is None and files is not None:\n            paths = files\n        if paths is None and dirs is not None:\n            paths = dirs\n        config = self.get_config(paths)\n        if not config:\n            return\n        else:\n            printer = PanelPrinter.get(self.window.id())\n            path = self.get_path(paths)\n            if os.path.isdir(path):\n                path = canonicalize(path, 'local')\n            remote_path = local_to_remote(path, config['path_map'])\n            type_ = path_type(remote_path)\n\n            def on_done(index):\n                if index == -1 or index == 1:\n                    return\n                printer.show()\n                DeleteLocalAndRemotePathThread(self.window, config, path, remote_path).start()\n\n            choices = [\n             [\n              'Yes', 'Delete local and remote %ss %s' % (type_, os.path.basename(remote_path.rstrip('/\\\\')))],\n             [\n              'No', 'Do not delete local and remote %ss %s' % (type_, os.path.basename(remote_path.rstrip('/\\\\')))]]\n            show_qp(self.window, choices, on_done)\n            return\n\n    def is_visible(self, paths=None, files=None, dirs=None):\n        if paths is None and files is None and dirs is None:\n            active_view = self.window.active_view()\n            if active_view and active_view.settings().get('is_remote'):\n                return False\n        if dirs == [] or files == []:\n            return False\n        else:\n            if paths is None and files is not None:\n                paths = files\n            if paths is None and dirs is not None:\n                paths = dirs\n            path = self.get_path(paths)\n            if not path:\n                return False\n            return self.has_config(path)\n\n\nclass DeleteLocalAndRemotePathThread(HookedThread):\n\n    def __init__(self, window, config, path, remote_path):\n        self.window_id = window.id()\n        self.config = config\n        self.path = path\n        self.remote_path = remote_path\n        super(DeleteLocalAndRemotePathThread, self).__init__()\n\n    def run(self):\n        last_thread = ThreadTracker.get_last_added(self.window_id)\n        ThreadTracker.add(self)\n        if last_thread is not None:\n            last_thread.join()\n        if is_dir(self.remote_path):\n            list_thread = SftpThread(self.window_id, self.config, self.remote_path, 'listr', should_join=False, hide=False, skip_symlinks='file')\n            list_thread.start()\n            list_thread.join()\n            if list_thread.failed and list_thread.result in ('File not found', 'Folder not found'):\n                remote_paths = []\n            else:\n                if list_thread.failed or not list_thread.result:\n                    return\n                remote_paths = [p[0] for p in list_thread.result[::-1]]\n        else:\n            remote_paths = self.remote_path\n        if remote_paths:\n            rm_thread = SftpThread(self.window_id, self.config, remote_paths, 'rm', should_join=False)\n            rm_thread.start()\n            rm_thread.join()\n            if rm_thread.failed and rm_thread.result not in ('File not found', 'Folder not found'):\n                return\n        if is_dir(self.path):\n            shutil.rmtree(self.path)\n        else:\n            os.remove(self.path)\n        return\n\n\nclass SftpDeleteRemotePathCommand(sublime_plugin.WindowCommand, SftpCommand):\n\n    def run(self, paths=None, files=None, dirs=None):\n        if paths is None and files is not None:\n            paths = files\n        if paths is None and dirs is not None:\n            paths = dirs\n        config = self.get_config(paths)\n        if not config:\n            return\n        else:\n            printer = PanelPrinter.get(self.window.id())\n            path = self.get_path(paths)\n            remote_path = local_to_remote(path, config['path_map'])\n            type_ = path_type(remote_path)\n\n            def on_done(index):\n                if index == -1 or index == 1:\n                    return\n                printer.show()\n                DeleteRemotePathThread(self.window, config, remote_path).start()\n\n            choices = [\n             [\n              'Yes', 'Delete remote %s %s' % (type_, os.path.basename(remote_path.rstrip('/\\\\')))],\n             [\n              'No', 'Do not delete remote %s %s' % (type_, os.path.basename(remote_path.rstrip('/\\\\')))]]\n            show_qp(self.window, choices, on_done)\n            return\n\n    def is_visible(self, paths=None, files=None, dirs=None):\n        if paths is None and files is None and dirs is None:\n            active_view = self.window.active_view()\n            if active_view and active_view.settings().get('is_remote'):\n                return False\n        if dirs == [] or files == []:\n            return False\n        else:\n            if paths is None and files is not None:\n                paths = files\n            if paths is None and dirs is not None:\n                paths = dirs\n            path = self.get_path(paths)\n            if not path:\n                return False\n            return self.has_config(path)\n\n\nclass DeleteRemotePathThread(HookedThread):\n\n    def __init__(self, window, config, remote_path):\n        self.window_id = window.id()\n        self.config = config\n        self.remote_path = remote_path\n        super(DeleteRemotePathThread, self).__init__()\n\n    def run(self):\n        last_thread = ThreadTracker.get_last_added(self.window_id)\n        ThreadTracker.add(self)\n        if last_thread is not None:\n            last_thread.join()\n        if is_dir(self.remote_path):\n            list_thread = SftpThread(self.window_id, self.config, self.remote_path, 'listr', should_join=False, hide=False, skip_symlinks='file')\n            list_thread.start()\n            list_thread.join()\n            if list_thread.failed or not list_thread.result:\n                return\n            remote_paths = [p[0] for p in list_thread.result[::-1]]\n        else:\n            remote_paths = self.remote_path\n        rm_thread = SftpThread(self.window_id, self.config, remote_paths, 'rm', should_join=False)\n        rm_thread.start()\n        rm_thread.join()\n        return\n\n\nclass SftpDownloadFileCommand(sublime_plugin.WindowCommand, SftpCommand):\n\n    def run(self, paths=None):\n        config = self.get_config(paths)\n        if not config:\n            return\n        else:\n            self.printer = PanelPrinter.get(self.window.id())\n            file = self.get_path(paths)\n            view = self.window.active_view()\n            self.on_complete = None\n            if view and view.file_name() == file:\n                self.on_complete = lambda : view.run_command('revert')\n            self.remote_file = local_to_remote(file, config['path_map'])\n            self.config = config\n            if not config['confirm_downloads']:\n                self.do_download()\n                return\n            debug_print('SFTP: Starting Confirm Download File Thread', 2)\n            basename = os.path.basename(file)\n            if os.name != 'nt':\n                basename = unicodedata.normalize('NFC', basename)\n            choices = [['Yes', 'Download the file %s' % basename],\n             [\n              'No', 'Do not download the file %s' % basename]]\n\n            def on_choose(index):\n                if index == -1 or index == 1:\n                    return\n                self.do_download()\n\n            show_qp(self.window, choices, on_choose)\n            return\n\n    def do_download(self):\n        self.printer.show()\n        debug_print('SFTP: Starting Download File Thread', 2)\n        SftpThread(self.window.id(), self.config, self.remote_file, 'get', on_complete=self.on_complete).start()\n\n    def is_visible(self, paths=None):\n        path = self.get_path(paths)\n        if not path or os.path.isdir(path):\n            return False\n        return self.has_config(path)\n\n\nclass SftpUploadFolderCommand(sublime_plugin.WindowCommand, SftpCommand):\n\n    def run(self, paths=None):\n        config = self.get_config(paths)\n        if not config:\n            return\n        dir = self.get_path(paths)\n        if not os.path.isdir(dir):\n            dir = dirname(dir)\n        dir = canonicalize(dir, 'local')\n        debug_print('SFTP: Starting Upload Folder Command Thread', 2)\n        UploadFolderThread(self.window, config, dir, self.save_files).start()\n\n    def is_visible(self, paths=None):\n        if paths is None:\n            active_view = self.window.active_view()\n            if active_view and active_view.settings().get('is_remote'):\n                return False\n        path = self.get_path(paths)\n        if not path:\n            return False\n        else:\n            return self.has_config(path)\n\n\nclass UploadFolderThread(HookedThread):\n\n    def __init__(self, window, config, dir, save_files):\n        self.config = config\n        self.printer = PanelPrinter.get(window.id())\n        self.window_id = window.id()\n        self.dir = dir\n        self.save_files = save_files\n        super(UploadFolderThread, self).__init__()\n\n    def run(self):\n        last_thread = ThreadTracker.get_last_added(self.window_id)\n        ThreadTracker.add(self)\n        if last_thread is not None:\n            last_thread.join()\n\n        def do_run():\n            self.printer.show()\n            basename = os.path.basename(self.dir.rstrip('/\\\\'))\n            progress = ProgressThread(self.printer, '\\nUploading folder \"%s\"' % basename)\n            paths = [\n             self.dir]\n            for root, dirs, files in os.walk(self.dir):\n                paths.extend([os.path.join(root, path) for path in dirs])\n                paths.extend([os.path.join(root, path) for path in files])\n\n            paths, to_upload, ignored = ignore_paths(paths, self.config)\n            paths.sort()\n            message = '%d %s to upload' % (to_upload, 'files' if to_upload != 1 else 'file')\n            if ignored:\n                message += ', %d ignored' % ignored\n            progress.stop(message)\n            progress.join()\n            if paths:\n                if self.config['save_before_upload']:\n                    self.save_files(paths)\n                debug_print('SFTP: Starting Upload Folder Thread', 2)\n                SftpThread(self.window_id, self.config, paths, 'put').start()\n            else:\n                self.printer.hide()\n\n        sublime.set_timeout(do_run, 10)\n        return\n\n\nclass SftpSyncUpCommand(sublime_plugin.WindowCommand, SftpCommand):\n\n    def run(self, paths=None, ignore_delete=False, on_complete=None):\n        config = self.get_config(paths)\n        if not config:\n            return\n        printer = PanelPrinter.get(self.window.id())\n        printer.show()\n        path = self.get_path(paths)\n        if os.path.isdir(path):\n            path = canonicalize(path, 'local')\n        if os.name != 'nt':\n            path = unicodedata.normalize('NFC', path)\n        if config.get('sync_skip_deletes'):\n            ignore_delete = True\n        debug_print('SFTP: Starting Sync Up Command Thread', 2)\n        SyncUpThread(self.window, config, path, self.save_files, ignore_delete, on_complete).start()\n\n    def is_visible(self, paths=None):\n        if paths is None:\n            active_view = self.window.active_view()\n            if active_view and active_view.settings().get('is_remote'):\n                return False\n        path = self.get_path(paths)\n        if not path:\n            return False\n        else:\n            return self.has_config(path)\n\n\nclass SyncUpThread(HookedThread, SyncThread):\n\n    def __init__(self, window, config, path, save_files, ignore_delete, on_complete):\n        self.config = config\n        self.printer = PanelPrinter.get(window.id())\n        self.window = window\n        self.window_id = window.id()\n        self.path = path\n        self.save_files = save_files\n        self.ignore_delete = ignore_delete\n        self.on_complete = on_complete\n        super(SyncUpThread, self).__init__()\n\n    def run(self):\n        last_thread = ThreadTracker.get_last_added(self.window_id)\n        ThreadTracker.add(self)\n        if last_thread is not None:\n            last_thread.join()\n        path_map = self.config['path_map']\n        path = self.path\n        remote_path = local_to_remote(path, path_map, self.config['remote_encoding'])\n        list_operation = 'listr' if is_dir(path) else 'list'\n        nonlocal_ = {'progress': None}\n\n        def on_connect():\n            nonlocal_['progress'] = ProgressThread(self.printer, '\\nDetermining operations to sync local path \"%s\" up to remote path \"%s\"' % (path, remote_path))\n\n        def on_fail(e):\n            if nonlocal_['progress']:\n                nonlocal_['progress'].stop('failure (%s)' % str(e))\n                nonlocal_['progress'].join()\n\n        dir = path if is_dir(path) else dirname(path)\n        remote_dir = local_to_remote(dir, path_map, self.config['remote_encoding'])\n        try:\n            list_dir_thread = SftpThread(self.window_id, self.config, remote_dir, list_operation, should_join=False, hide=False, on_connect=on_connect, on_fail=on_fail, quiet=True, skip_symlinks=False)\n            list_dir_thread.start()\n            list_dir_thread.join()\n        except UnicodeDecodeError as e:\n            if nonlocal_['progress']:\n                nonlocal_['progress'].stop('failure (Encoding error)')\n                nonlocal_['progress'].join()\n            encoding_error(e)\n            return\n\n        if list_dir_thread.failed and list_dir_thread.result in ('File not found',\n                                                                 'Folder not found'):\n            remote_paths = []\n        else:\n            if list_dir_thread.failed:\n                return\n            remote_paths = list_dir_thread.result\n        list_dir_thread = SftpThread(self.window_id, self.config, dir, 'l' + list_operation, should_join=False, hide=False)\n        list_dir_thread.start()\n        list_dir_thread.join()\n        if list_dir_thread.failed and list_dir_thread.result in ('File not found',\n                                                                 'Folder not found'):\n            local_paths = []\n        else:\n            if list_dir_thread.failed:\n                return\n            local_paths = list_dir_thread.result\n        if not is_dir(path):\n            local_paths = [[os.path.join(dir, _path[0]), _path[1]] for _path in local_paths if os.path.join(dir, _path[0]) == path]\n            remote_paths = [[os.path.join(remote_dir, _path[0]), _path[1]] for _path in remote_paths if os.path.join(remote_dir, _path[0]) == remote_path]\n        local_dict = dict(local_paths)\n        remote_dict = dict(remote_paths)\n        debug_print('SFTP: Sync Up Local Files\\n    %s' % repr(local_paths), 2)\n        debug_print('SFTP: Sync Up Remote Files\\n    %s' % repr(remote_paths), 2)\n        to_rm = set([path_[0] for path_ in remote_paths])\n        to_put = []\n        to_put_new = []\n        to_put_overwrite = []\n        for local_path, local_time in local_paths:\n            remote_path = local_to_remote(local_path, path_map)\n            remote_time = remote_dict.get(remote_path)\n            if remote_time is None:\n                to_put_new.append(local_path)\n                to_put.append(local_path)\n            else:\n                if remote_time <= local_time and not is_dir(local_path):\n                    to_put_overwrite.append(local_path)\n                    to_put.append(local_path)\n            to_rm = to_rm - set([remote_path])\n\n        to_rm = list(to_rm)\n        to_rm = sorted(to_rm, key=lambda s: s.lower())\n        to_put, num_to_put, num_to_put_ignored = ignore_paths(to_put, self.config)\n        to_put_new, num_to_put, num_to_put_ignored = ignore_paths(to_put_new, self.config)\n        to_put_overwrite, num_to_put, num_to_put_ignored = ignore_paths(to_put_overwrite, self.config)\n        to_rm, num_to_rm, num_to_rm_ignored = ignore_rm_paths(to_rm, self.config, 'remote')\n        if self.ignore_delete:\n            to_rm = []\n        operations = []\n        for local_path in to_put:\n            local_time = self.make_time(local_dict.get(local_path))\n            remote_path = local_to_remote(local_path, path_map)\n            remote_time = self.make_time(remote_dict.get(remote_path))\n            if is_dir(remote_path):\n                operation = 'Create remote \"%s\"' % self.strip(remote_path, remote_dir, 'remote')\n            else:\n                if remote_time == 'None':\n                    operation = 'Upload local \"%s\" to remote \"%s\"' % (\n                     self.strip(local_path, dir, 'local'),\n                     self.strip(remote_path, remote_dir, 'remote'))\n                else:\n                    diff = time_diff(local_dict.get(local_path), remote_dict.get(remote_path))\n                    if diff == 'same age' and not self.config['sync_same_age']:\n                        to_put_overwrite.remove(local_path)\n                        continue\n                    operation = 'Upload local \"%s\" (%s) over remote \"%s\" [%s vs. %s]' % (\n                     self.strip(local_path, dir, 'local'),\n                     diff, self.strip(remote_path, remote_dir, 'remote'),\n                     local_time, remote_time)\n                operations.append(operation)\n\n        operations += ['Delete remote path \"%s\"' % self.strip(path_, remote_dir, 'remote') for path_ in to_rm]\n        if operations:\n            if nonlocal_['progress']:\n                nonlocal_['progress'].stop('success')\n                nonlocal_['progress'].join()\n\n            def handle_yes():\n                failed = False\n                if to_put_new:\n                    put_thread = SftpThread(self.window_id, self.config, to_put_new, 'put', should_join=False)\n                    put_thread.start()\n                    put_thread.join()\n                    failed = failed or put_thread.failed\n                if to_put_overwrite:\n                    put_thread = SftpThread(self.window_id, self.config, to_put_overwrite, 'put', should_join=False)\n                    put_thread.start()\n                    put_thread.join()\n                    failed = failed or put_thread.failed\n                if to_rm:\n                    to_rm.reverse()\n                    rm_thread = SftpThread(self.window_id, self.config, to_rm, 'rm', should_join=False)\n                    rm_thread.start()\n                    rm_thread.join()\n                    failed = failed or rm_thread.failed\n                if not failed and self.on_complete:\n                    self.on_complete()\n                if not failed:\n                    sublime.set_timeout(lambda : self.printer.hide(), 1)\n\n            if self.config.get('confirm_sync'):\n\n                def handle_no():\n                    sublime.set_timeout(lambda : self.printer.hide(), 1)\n\n                self.confirm(operations, handle_yes, handle_no, should_join=True)\n            else:\n                handle_yes()\n        else:\n            if nonlocal_['progress']:\n                nonlocal_['progress'].stop('success (No operations to perform)')\n                nonlocal_['progress'].join()\n            sublime.set_timeout(lambda : self.printer.hide(), 1)\n        return\n\n\nclass SftpSyncDownCommand(sublime_plugin.WindowCommand, SftpCommand):\n\n    def run(self, paths=None, ignore_delete=False, on_complete=None, reset_lcd=None, synchronous=False):\n        config = self.get_config(paths)\n        if not config:\n            return\n        printer = PanelPrinter.get(self.window.id())\n        printer.show()\n        path = self.get_path(paths)\n        if os.path.isdir(path):\n            path = canonicalize(path, 'local')\n        if os.name != 'nt':\n            path = unicodedata.normalize('NFC', path)\n        if config.get('sync_skip_deletes'):\n            ignore_delete = True\n        debug_print('SFTP: Starting Sync Down Command Thread', 2)\n        SyncDownThread(self.window, config, path, self.save_files, ignore_delete, on_complete, reset_lcd, synchronous).start()\n\n    def is_visible(self, paths=None):\n        if paths is None:\n            active_view = self.window.active_view()\n            if active_view and active_view.settings().get('is_remote'):\n                return False\n        path = self.get_path(paths)\n        if not path:\n            return False\n        else:\n            return self.has_config(path)\n\n\nclass SyncDownThread(HookedThread, SyncThread):\n\n    def __init__(self, window, config, path, save_files, ignore_delete, on_complete, reset_lcd, synchronous):\n        self.config = config\n        self.printer = PanelPrinter.get(window.id())\n        self.window = window\n        self.window_id = window.id()\n        self.path = path\n        self.save_files = save_files\n        self.ignore_delete = ignore_delete\n        self.on_complete = on_complete\n        self.reset_lcd = reset_lcd\n        self.synchronous = synchronous\n        super(SyncDownThread, self).__init__()\n\n    def run(self):\n        last_thread = ThreadTracker.get_last_added(self.window_id)\n        ThreadTracker.add(self)\n        if last_thread is not None:\n            last_thread.join()\n        path_map = self.config['path_map']\n        path = self.path\n        remote_path = local_to_remote(path, path_map, self.config['remote_encoding'])\n        list_operation = 'listr' if is_dir(path) else 'list'\n        nonlocal_ = {'progress': None}\n\n        def on_connect():\n            nonlocal_['progress'] = ProgressThread(self.printer, '\\nDetermining operations to sync remote path \"%s\" down to local path \"%s\"' % (remote_path, path))\n\n        def on_fail(e):\n            if nonlocal_['progress']:\n                nonlocal_['progress'].stop('failure (%s)' % str(e))\n                nonlocal_['progress'].join()\n\n        dir = path if is_dir(path) else canonicalize(dirname(path), 'local')\n        remote_dir = local_to_remote(dir, path_map, self.config['remote_encoding'])\n        list_dir_thread = SftpThread(self.window_id, self.config, remote_dir, list_operation, should_join=False, hide=False, on_connect=on_connect, on_fail=on_fail, quiet=True, skip_symlinks=False)\n        list_dir_thread.start()\n        list_dir_thread.join()\n        if list_dir_thread.failed and list_dir_thread.result in ('File not found',\n                                                                 'Folder not found'):\n            remote_paths = []\n        else:\n            if list_dir_thread.failed:\n                return\n            remote_paths = list_dir_thread.result\n        list_dir_thread = SftpThread(self.window_id, self.config, dir, 'l' + list_operation, should_join=False, hide=False)\n        list_dir_thread.start()\n        list_dir_thread.join()\n        if list_dir_thread.failed and list_dir_thread.result in ('File not found',\n                                                                 'Folder not found'):\n            local_paths = []\n        else:\n            if list_dir_thread.failed:\n                return\n            local_paths = list_dir_thread.result\n        if not is_dir(path):\n            local_paths = [[os.path.join(dir, _path[0]), _path[1]] for _path in local_paths if os.path.join(dir, _path[0]) == path]\n            remote_paths = [[os.path.join(remote_dir, _path[0]), _path[1]] for _path in remote_paths if os.path.join(remote_dir, _path[0]) == remote_path]\n        local_dict = dict(local_paths)\n        remote_dict = dict(remote_paths)\n        debug_print('SFTP: Sync Down Local Files\\n    %s' % repr(local_paths), 2)\n        debug_print('SFTP: Sync Down Remote Files\\n    %s' % repr(remote_paths), 2)\n        to_rm = set([path_[0] for path_ in local_paths])\n        to_get = []\n        to_get_new = []\n        to_get_overwrite = []\n        for remote_path, remote_time in remote_paths:\n            local_path = remote_to_local(remote_path, path_map)\n            local_time = local_dict.get(local_path)\n            if local_time is None:\n                to_get_new.append(remote_path)\n                to_get.append(remote_path)\n            else:\n                if local_time <= remote_time and not is_dir(local_path):\n                    to_get_overwrite.append(remote_path)\n                    to_get.append(remote_path)\n            to_rm = to_rm - set([local_path])\n\n        to_rm = list(to_rm)\n        to_rm = sorted(to_rm, key=lambda s: s.lower())\n        to_get, num_to_get, num_to_get_ignored = ignore_paths(to_get, self.config)\n        to_get_new, num_to_get, num_to_get_ignored = ignore_paths(to_get_new, self.config)\n        to_get_overwrite, num_to_get, num_to_get_ignored = ignore_paths(to_get_overwrite, self.config)\n        to_rm, num_to_rm, num_to_rm_ignored = ignore_rm_paths(to_rm, self.config, 'local')\n        if self.ignore_delete:\n            to_rm = []\n        operations = []\n        for remote_path in to_get:\n            remote_time = self.make_time(remote_dict.get(remote_path))\n            local_path = remote_to_local(remote_path, path_map)\n            local_time = self.make_time(local_dict.get(local_path))\n            if is_dir(local_path):\n                operation = 'Create local \"%s\"' % self.strip(local_path, dir, 'local')\n            else:\n                if local_time == 'None':\n                    operation = 'Download remote \"%s\" to \"%s\"' % (\n                     self.strip(remote_path, remote_dir, 'remote'),\n                     self.strip(local_path, dir, 'local'))\n                else:\n                    diff = time_diff(remote_dict.get(remote_path), local_dict.get(local_path))\n                    if diff == 'same age' and not self.config['sync_same_age']:\n                        to_get_overwrite.remove(remote_path)\n                        continue\n                    operation = 'Download remote \"%s\" (%s) over local \"%s\" [%s vs. %s]' % (\n                     self.strip(remote_path, remote_dir, 'remote'),\n                     diff, self.strip(local_path, dir, 'local'),\n                     remote_time, local_time)\n                operations.append(operation)\n\n        operations += ['Delete local \"%s\"' % self.strip(path_, dir, 'local') for path_ in to_rm]\n        if operations:\n            if nonlocal_['progress']:\n                nonlocal_['progress'].stop('success')\n                nonlocal_['progress'].join()\n            nonlocal_['done'] = False\n\n            def handle_yes():\n                failed = False\n                if to_get_new:\n                    get_thread = SftpThread(self.window_id, self.config, to_get_new, 'get', should_join=False, reset_lcd=self.reset_lcd)\n                    get_thread.start()\n                    get_thread.join()\n                    failed = failed or get_thread.failed\n                if to_get_overwrite:\n                    get_thread = SftpThread(self.window_id, self.config, to_get_overwrite, 'get', should_join=False, reset_lcd=self.reset_lcd)\n                    get_thread.start()\n                    get_thread.join()\n                    failed = failed or get_thread.failed\n                if to_rm:\n                    to_rm.reverse()\n                    rm_thread = SftpThread(self.window_id, self.config, to_rm, 'lrm', should_join=False)\n                    rm_thread.start()\n                    rm_thread.join()\n                    failed = failed or rm_thread.failed\n                if not failed and self.on_complete:\n                    if self.on_complete == 'open_refresh':\n\n                        def do_refresh():\n                            if not to_get:\n                                return\n                            local_path = remote_to_local(to_get[0], path_map)\n                            self.window.run_command('open_file', {'file': fix_windows_path(local_path)})\n                            self.window.active_view().run_command('revert')\n\n                        sublime.set_timeout(do_refresh, 1)\n                    else:\n                        self.on_complete()\n                if not failed:\n                    sublime.set_timeout(lambda : self.printer.hide(), 1)\n                nonlocal_['done'] = True\n\n            if self.config.get('confirm_sync'):\n\n                def handle_no():\n                    sublime.set_timeout(lambda : self.printer.hide(), 1)\n                    nonlocal_['done'] = True\n\n                self.confirm(operations, handle_yes, handle_no, should_join=not self.synchronous)\n                if self.synchronous:\n                    while True:\n                        if nonlocal_['done']:\n                            break\n                        time.sleep(0.01)\n\n            else:\n                handle_yes()\n        else:\n            if nonlocal_['progress']:\n                nonlocal_['progress'].stop('success (No operations to perform)')\n                nonlocal_['progress'].join()\n            sublime.set_timeout(lambda : self.printer.hide(), 1)\n        return\n\n\nclass SftpSyncBothCommand(sublime_plugin.WindowCommand, SftpCommand):\n\n    def run(self, paths=None, on_complete=None):\n        config = self.get_config(paths)\n        if not config:\n            return\n        printer = PanelPrinter.get(self.window.id())\n        printer.show()\n        path = self.get_path(paths)\n        if os.path.isdir(path):\n            path = canonicalize(path, 'local')\n        if os.name != 'nt':\n            path = unicodedata.normalize('NFC', path)\n        debug_print('SFTP: Starting Sync Both Command Thread', 2)\n        SyncBothThread(self.window, config, path, self.save_files, on_complete).start()\n\n    def is_visible(self, paths=None):\n        if paths is None:\n            active_view = self.window.active_view()\n            if active_view and active_view.settings().get('is_remote'):\n                return False\n        path = self.get_path(paths)\n        if not path:\n            return False\n        else:\n            return self.has_config(path)\n\n\nclass SyncBothThread(HookedThread, SyncThread):\n\n    def __init__(self, window, config, path, save_files, on_complete):\n        self.config = config\n        self.printer = PanelPrinter.get(window.id())\n        self.window = window\n        self.window_id = window.id()\n        self.path = path\n        self.save_files = save_files\n        self.on_complete = on_complete\n        super(SyncBothThread, self).__init__()\n\n    def run(self):\n        last_thread = ThreadTracker.get_last_added(self.window_id)\n        ThreadTracker.add(self)\n        if last_thread is not None:\n            last_thread.join()\n        path_map = self.config['path_map']\n        path = self.path\n        remote_path = local_to_remote(path, path_map, self.config['remote_encoding'])\n        nonlocal_ = {'progress': None}\n\n        def on_connect():\n            nonlocal_['progress'] = ProgressThread(self.printer, '\\nDetermining operations to sync local path \"%s\" both directions with remote path \"%s\"' % (path, remote_path))\n\n        def on_fail(e):\n            if nonlocal_['progress']:\n                nonlocal_['progress'].stop('failure (%s)' % str(e))\n                nonlocal_['progress'].join()\n\n        dir = path if is_dir(path) else dirname(path)\n        remote_dir = local_to_remote(dir, path_map, self.config['remote_encoding'])\n        list_dir_thread = SftpThread(self.window_id, self.config, remote_dir, 'listr', should_join=False, hide=False, on_connect=on_connect, on_fail=on_fail, quiet=True, skip_symlinks=False)\n        list_dir_thread.start()\n        list_dir_thread.join()\n        if list_dir_thread.failed and list_dir_thread.result in ('File not found',\n                                                                 'Folder not found'):\n            remote_paths = []\n        else:\n            if list_dir_thread.failed:\n                return\n            remote_paths = list_dir_thread.result\n        list_dir_thread = SftpThread(self.window_id, self.config, dir, 'llistr', should_join=False, hide=False)\n        list_dir_thread.start()\n        list_dir_thread.join()\n        if list_dir_thread.failed and list_dir_thread.result in ('File not found',\n                                                                 'Folder not found'):\n            local_paths = []\n        else:\n            if list_dir_thread.failed:\n                return\n            local_paths = list_dir_thread.result\n        if not is_dir(path):\n            local_paths = [_path for _path in local_paths if _path[0] == path]\n            remote_paths = [_path for _path in remote_paths if _path[0] == remote_path]\n        local_dict = dict(local_paths)\n        remote_dict = dict(remote_paths)\n        debug_print('SFTP: Sync Both Local Files\\n    %s' % repr(local_paths), 2)\n        debug_print('SFTP: Sync Both Remote Files\\n    %s' % repr(remote_paths), 2)\n        to_put = []\n        to_put_new = []\n        to_put_overwrite = []\n        to_get = []\n        to_get_new = []\n        to_get_overwrite = []\n        for local_path, local_time in local_paths:\n            remote_path = local_to_remote(local_path, path_map)\n            remote_time = remote_dict.get(remote_path)\n            if remote_time is None:\n                to_put_new.append(local_path)\n                to_put.append(local_path)\n            elif remote_time <= local_time and not is_dir(local_path):\n                to_put_overwrite.append(local_path)\n                to_put.append(local_path)\n                continue\n\n        for remote_path, remote_time in remote_paths:\n            local_path = remote_to_local(remote_path, path_map)\n            local_time = local_dict.get(local_path)\n            if local_time is None:\n                to_get_new.append(remote_path)\n                to_get.append(remote_path)\n            elif local_time < remote_time and not is_dir(remote_path):\n                to_get_overwrite.append(remote_path)\n                to_get.append(remote_path)\n                continue\n\n        to_put, num_to_put, num_to_put_ignored = ignore_paths(to_put, self.config)\n        to_put_new, num_to_put, num_to_put_ignored = ignore_paths(to_put_new, self.config)\n        to_put_overwrite, num_to_put, num_to_put_ignored = ignore_paths(to_put_overwrite, self.config)\n        to_get, num_to_get, num_to_get_ignored = ignore_paths(to_get, self.config)\n        to_get_new, num_to_get, num_to_get_ignored = ignore_paths(to_get_new, self.config)\n        to_get_overwrite, num_to_get, num_to_get_ignored = ignore_paths(to_get_overwrite, self.config)\n        operations = []\n        for local_path in to_put:\n            local_time = self.make_time(local_dict.get(local_path))\n            remote_path = local_to_remote(local_path, path_map)\n            remote_time = self.make_time(remote_dict.get(remote_path))\n            if is_dir(remote_path):\n                operation = 'Create remote \"%s\"' % self.strip(remote_path, remote_dir, 'remote')\n            else:\n                if remote_time == 'None':\n                    operation = 'Upload local \"%s\" to remote \"%s\"' % (\n                     self.strip(local_path, dir, 'local'),\n                     self.strip(remote_path, remote_dir, 'remote'))\n                else:\n                    diff = time_diff(local_dict.get(local_path), remote_dict.get(remote_path))\n                    if diff == 'same age' and not self.config['sync_same_age']:\n                        to_put_overwrite.remove(local_path)\n                        continue\n                    operation = 'Upload local \"%s\" (%s) over remote \"%s\" [%s vs. %s]' % (\n                     self.strip(local_path, dir, 'local'),\n                     diff, self.strip(remote_path, remote_dir, 'remote'),\n                     local_time, remote_time)\n                operations.append(operation)\n\n        for remote_path in to_get:\n            remote_time = self.make_time(remote_dict.get(remote_path))\n            local_path = remote_to_local(remote_path, path_map)\n            local_time = self.make_time(local_dict.get(local_path))\n            if is_dir(local_path):\n                operation = 'Create local \"%s\"' % self.strip(local_path, dir, 'local')\n            else:\n                if local_time == 'None':\n                    operation = 'Download remote \"%s\" to \"%s\"' % (\n                     self.strip(remote_path, remote_dir, 'remote'),\n                     self.strip(local_path, dir, 'local'))\n                else:\n                    diff = time_diff(remote_dict.get(remote_path), local_dict.get(local_path))\n                    if diff == 'same age' and not self.config['sync_same_age']:\n                        to_get_overwrite.remove(remote_path)\n                        continue\n                    operation = 'Download remote \"%s\" (%s) over local \"%s\" [%s vs. %s]' % (\n                     self.strip(remote_path, remote_dir, 'remote'),\n                     diff, self.strip(local_path, dir, 'local'),\n                     remote_time, local_time)\n                operations.append(operation)\n\n        if operations:\n            if nonlocal_['progress']:\n                nonlocal_['progress'].stop('success')\n                nonlocal_['progress'].join()\n\n            def handle_yes():\n                failed = False\n                if to_put_new:\n                    put_thread = SftpThread(self.window_id, self.config, to_put_new, 'put', should_join=False)\n                    put_thread.start()\n                    put_thread.join()\n                    failed = failed or put_thread.failed\n                if to_put_overwrite:\n                    put_thread = SftpThread(self.window_id, self.config, to_put_overwrite, 'put', should_join=False)\n                    put_thread.start()\n                    put_thread.join()\n                    failed = failed or put_thread.failed\n                if to_get_new:\n                    get_thread = SftpThread(self.window_id, self.config, to_get_new, 'get', should_join=False)\n                    get_thread.start()\n                    get_thread.join()\n                    failed = failed or get_thread.failed\n                if to_get_overwrite:\n                    get_thread = SftpThread(self.window_id, self.config, to_get_overwrite, 'get', should_join=False)\n                    get_thread.start()\n                    get_thread.join()\n                    failed = failed or get_thread.failed\n                if not failed and self.on_complete:\n                    self.on_complete()\n                if not failed:\n                    sublime.set_timeout(lambda : self.printer.hide(), 1)\n\n            if self.config.get('confirm_sync'):\n\n                def handle_no():\n                    sublime.set_timeout(lambda : self.printer.hide(), 1)\n\n                self.confirm(operations, handle_yes, handle_no, should_join=True)\n            else:\n                handle_yes()\n        else:\n            if nonlocal_['progress']:\n                nonlocal_['progress'].stop('success (No operations to perform)')\n                nonlocal_['progress'].join()\n            sublime.set_timeout(lambda : self.printer.hide(), 1)\n        return\n\n\nclass SftpDownloadFolderCommand(sublime_plugin.WindowCommand, SftpCommand):\n\n    def run(self, paths=None):\n        config = self.get_config(paths)\n        if not config:\n            return\n        self.printer = PanelPrinter.get(self.window.id())\n        dir = self.get_path(paths)\n        if not os.path.isdir(dir):\n            dir = dirname(dir)\n        self.remote_dir = local_to_remote(dir, config['path_map'])\n        self.config = config\n        if not config['confirm_downloads']:\n            self.do_download()\n            return\n        debug_print('SFTP: Starting Confirm Download Folder Thread', 2)\n        basename = os.path.basename(dir)\n        if os.name != 'nt':\n            basename = unicodedata.normalize('NFC', basename)\n        choices = [['Yes', 'Download the folder %s' % basename],\n         [\n          'No', 'Do not download the folder %s' % basename]]\n\n        def on_choose(index):\n            if index == -1 or index == 1:\n                return\n            self.do_download()\n\n        show_qp(self.window, choices, on_choose)\n\n    def do_download(self):\n        self.printer.show()\n        debug_print('SFTP: Starting Download Folder Command Thread', 2)\n        DownloadFolderThread(self.window.id(), self.config, self.remote_dir).start()\n\n    def is_visible(self, paths=None):\n        if paths is None:\n            active_view = self.window.active_view()\n            if active_view and active_view.settings().get('is_remote'):\n                return False\n        path = self.get_path(paths)\n        if not path:\n            return False\n        else:\n            return self.has_config(path)\n\n\nclass DownloadFolderThread(HookedThread):\n\n    def __init__(self, window_id, config, remote_dir):\n        self.config = config\n        self.printer = PanelPrinter.get(window_id)\n        self.window_id = window_id\n        self.remote_dir = remote_dir\n        self.error = False\n        super(DownloadFolderThread, self).__init__()\n\n    def run(self):\n        last_thread = ThreadTracker.get_last_added(self.window_id)\n        ThreadTracker.add(self)\n        if last_thread is not None:\n            last_thread.join()\n        nonlocal_ = {'progress': None}\n\n        def on_connect():\n            nonlocal_['progress'] = ProgressThread(self.printer, '\\nDownloading folder \"%s\"' % self.remote_dir)\n\n        list_dir_thread = SftpThread(self.window_id, self.config, self.remote_dir, 'listr', should_join=False, on_connect=on_connect, hide=False, skip_symlinks=False)\n        list_dir_thread.start()\n        list_dir_thread.join()\n        remote_paths = list_dir_thread.result\n        if remote_paths is not None:\n            remote_paths = [path[0] for path in remote_paths]\n            remote_paths, to_download, ignored = ignore_paths(remote_paths, self.config)\n            message = ' %d %s to download' % (to_download, 'files' if to_download != 1 else 'file')\n            if ignored:\n                message += ', %d ignored' % ignored\n        else:\n            message = 'failure (Error)'\n        if nonlocal_['progress']:\n            nonlocal_['progress'].stop(message)\n            nonlocal_['progress'].join()\n        if remote_paths:\n            debug_print('SFTP: Starting Download Folder Thread', 2)\n            download_thread = SftpThread(self.window_id, self.config, remote_paths, 'get', should_join=False)\n            download_thread.start()\n            download_thread.join()\n            self.error = download_thread.failed\n        else:\n            sublime.set_timeout(lambda : self.printer.hide(), 1)\n        return\n\n\nclass SftpVcsChangedFilesCommand(sublime_plugin.WindowCommand, SftpCommand):\n\n    def run(self):\n        config = self.get_config()\n        if not config:\n            return\n        else:\n            printer = PanelPrinter.get(self.window.id())\n            printer.show()\n            vcs = None\n            path = self.get_path()\n            settings = sublime.load_settings('SFTP.sublime-settings')\n            vcses = [\n             (\n              SVN, settings.get('svn_binary_path')),\n             (\n              Git, settings.get('git_binary_path')),\n             (\n              Hg, settings.get('hg_binary_path'))]\n            for vcs_class, binary_path in vcses:\n                try:\n                    vcs = vcs_class(path, binary_path)\n                except NotFoundError:\n                    pass\n\n            if vcs is None:\n                printer.write('\\nLooking for changed files ... failure')\n                printer.error('The current file does not appear to be inside of an SVN, Git or Mercurial working copy')\n                return\n            if config['save_before_upload']:\n                self.save_files()\n            debug_print('SFTP: Starting VCS Command Thread', 2)\n            VcsThread(self.window, config, vcs).start()\n            return\n\n    def is_visible(self, paths=None):\n        path = self.get_path(paths)\n        if not path or os.path.isdir(path):\n            return False\n        return self.has_config(path)\n\n\nclass VcsThread(HookedThread):\n\n    def __init__(self, window, config, vcs):\n        self.window_id = window.id()\n        self.printer = PanelPrinter.get(window.id())\n        self.config = config\n        self.vcs = vcs\n        super(VcsThread, self).__init__()\n\n    def run(self):\n        last_thread = ThreadTracker.get_last_added(self.window_id)\n        ThreadTracker.add(self)\n        if last_thread is not None:\n            last_thread.join()\n        progress = ProgressThread(self.printer, '\\nLooking for changed files')\n        try:\n            files = self.vcs.list_changed_files()\n            files = [file for file in files if re.match(re.escape(self.config['local_dir']), file) is not None]\n        except NotFoundError as e:\n            progress.stop('failure\\n' + str(e))\n            progress.join()\n            self.printer.error(e)\n            return\n\n        to_upload = len(files)\n        ignored = 0\n        if 'ignore_regex' in self.config:\n            files = [file for file in files if not re.search(self.config['ignore_regex'], file)]\n            ignored = to_upload - len(files)\n            to_upload = len(files)\n        message = '%d %s to upload' % (to_upload, 'files' if to_upload != 1 else ' file')\n        if ignored:\n            message += ', %d ignored' % ignored\n        progress.stop(message)\n        progress.join()\n        if files:\n            debug_print('SFTP: Starting VCS Thread', 2)\n            SftpThread(self.window_id, self.config, files, 'put').start()\n        else:\n            sublime.set_timeout(self.printer.hide, 10)\n        return\n\n\nclass SftpCancelUploadCommand(sublime_plugin.WindowCommand, SftpCommand):\n\n    def run(self):\n        current_thread = ThreadTracker.get_current(self.window.id())\n        if current_thread:\n            current_thread.kill()\n\n    def is_visible(self, paths=None):\n        return ThreadTracker.get_current(self.window.id()) is not None\n\n\nclass SftpEditConfigCommand(sublime_plugin.WindowCommand, SftpCommand):\n\n    def run(self, paths=None):\n        path = self.get_path(paths)\n        if not path:\n            return\n        if not os.path.isdir(path):\n            path = os.path.dirname(path)\n        file = find_config(path, True)\n        file = fix_windows_path(file)\n        self.window.run_command('open_file', {'file': file})\n\n    def is_visible(self, paths=None):\n        path = self.get_path(paths)\n        if not path:\n            return False\n        if not os.path.isdir(path):\n            path = os.path.dirname(path)\n        config_file = find_config(path, True)\n        return config_file is not False\n\n    def is_enabled(self, paths=None):\n        path = self.get_path(paths)\n        if not path:\n            return False\n        if not os.path.isdir(path):\n            path = os.path.dirname(path)\n        config_file = find_config(path, True)\n        return config_file is not False\n\n\nclass SftpCreateConfigCommand(sublime_plugin.WindowCommand, SftpCommand):\n\n    def run(self, paths=None):\n        path = self.get_path(paths)\n        if not os.path.isdir(path):\n            path = os.path.dirname(path)\n        file = os.path.join(path, 'sftp-config.json')\n        self.create_default_config(file)\n\n        def open_file():\n            self.window.run_command('open_file', {'file': fix_windows_path(file)})\n\n            def run_snippet():\n                snippet = get_default_config()\n                view = self.window.active_view()\n                view.sel().add(sublime.Region(0, view.size()))\n                view.run_command('insert_snippet', {'contents': snippet})\n\n            sublime.set_timeout(run_snippet, 350)\n\n        sublime.set_timeout(open_file, 350)\n\n    def is_visible(self, paths=None):\n        path = self.get_path(paths)\n        if not path:\n            return False\n        if not os.path.isdir(path):\n            path = os.path.dirname(path)\n        return find_config(path, True) is False\n\n    def is_enabled(self, paths=None):\n        path = self.get_path(paths)\n        if not path:\n            return False\n        if not os.path.isdir(path):\n            path = os.path.dirname(path)\n        return find_config(path, True) is False\n\n\nclass SftpSwitchConfigCommand(sublime_plugin.WindowCommand, SftpCommand):\n\n    def run(self, paths=None):\n        path = self.get_path(paths)\n        if not path:\n            return\n        config_file = find_config(path, True)\n        if config_file is False:\n            return\n        self.config_dir = os.path.dirname(config_file)\n\n        def add_desc(config):\n            remote_type = config.get('type', 'sftp').upper()\n            user = config.get('user')\n            host = config.get('host')\n            remote_path = config.get('remote_path')\n            port = ':' + str(config.get('port')) if config.get('port') else ''\n            config['desc'] = '%s %s@%s%s %s' % (\n             remote_type, user, host, port, remote_path)\n            return config\n\n        alt_config_files = []\n        alt_configs = {}\n        for num in ['', '2', '3', '4', '5', '6', '7', '8', '9']:\n            alt_config_file = config_file.replace('sftp-settings.json', 'sftp-config.json')[0:-5] + '-alt' + num + '.json'\n            if os.path.exists(alt_config_file):\n                alt_config_files.append(alt_config_file)\n                alt_configs[alt_config_file] = add_desc(parse_config(alt_config_file))\n                continue\n\n        config = add_desc(parse_config(config_file))\n        self.choices = [\n         [\n          config['desc'], os.path.basename(config_file)]]\n        for alt_config_file in alt_config_files:\n            self.choices.append([alt_configs[alt_config_file]['desc'], os.path.basename(alt_config_file)])\n\n        self.window_id = self.window.id()\n        self.printer = PanelPrinter.get(self.window_id)\n        show_qp(self.window, self.choices, self.on_done)\n\n    def on_done(self, index):\n        if index == -1:\n            return\n        if index == 0:\n            return\n        main_config_file = os.path.join(self.config_dir, self.choices[0][1])\n        alt_config_file = os.path.join(self.config_dir, self.choices[index][1])\n        original_config = ''\n        with open(main_config_file, 'rb') as (f):\n            original_config = f.read()\n        new_config = ''\n        with open(alt_config_file, 'rb') as (f):\n            new_config = f.read()\n        with open(main_config_file, 'wb') as (f):\n            f.write(new_config)\n        with open(alt_config_file, 'wb') as (f):\n            f.write(original_config)\n\n    def is_visible(self, paths=None):\n        path = self.get_path(paths)\n        if not path:\n            return False\n        config_file = find_config(path, True)\n        if config_file is False:\n            return False\n        alt_config_file = config_file.replace('sftp-settings.json', 'sftp-config.json')[0:-5] + '-alt.json'\n        if os.path.exists(alt_config_file):\n            return True\n        return False\n\n\nclass SftpCreateAltConfigCommand(sublime_plugin.WindowCommand, SftpCommand):\n\n    def run(self, paths=None):\n        path = self.get_path(paths)\n        if not path:\n            return\n        config_file = find_config(path, True)\n        if config_file is False:\n            return\n        else:\n            new_config_file = None\n            for num in ['', '2', '3', '4', '5', '6', '7', '8', '9']:\n                alt_config_file = config_file.replace('sftp-settings.json', 'sftp-config.json')[0:-5] + '-alt' + num + '.json'\n                if not os.path.exists(alt_config_file):\n                    new_config_file = alt_config_file\n                    break\n\n            if not new_config_file:\n                sublime.error_message('Sublime SFTP\\n\\nThere can not be more than 9 alternate configs')\n                return False\n            original_config = ''\n            with open(config_file, 'rb') as (f):\n                original_config = f.read()\n            with open(new_config_file, 'wb') as (f):\n                f.write(original_config)\n            self.window.run_command('open_file', {'file': fix_windows_path(new_config_file)})\n            return\n\n    def is_visible(self, paths=None):\n        path = self.get_path(paths)\n        if not path:\n            return False\n        config_file = find_config(path, True)\n        if config_file is False:\n            return False\n        return True\n\n\nclass SftpCreateSubConfigCommand(sublime_plugin.WindowCommand, SftpCommand):\n\n    def run(self, dirs):\n        file = os.path.join(dirs[0], 'sftp-config.json')\n        self.create_default_config(file)\n        file = fix_windows_path(file)\n        self.window.run_command('open_file', {'file': file})\n\n    def is_visible(self, dirs):\n        path = self.first_path(dirs)\n        config_file = find_config(path, True)\n        return config_file is not False and os.path.dirname(config_file) != path\n\n    def is_enabled(self, dirs):\n        path = self.first_path(dirs)\n        config_file = find_config(path, True)\n        return config_file is not False and os.path.dirname(config_file) != path\n",
					"file": "/C/Users/cienet/AppData/Roaming/Sublime Text 3/Packages/SFTP/sftp/commands.py",
					"file_size": 126645,
					"file_write_time": 132495648953319491,
					"settings":
					{
						"buffer_size": 123677,
						"line_ending": "Windows"
					}
				},
				{
					"file": "/C/Users/cienet/AppData/Roaming/Sublime Text 3/Packages/SFTP/SFTP.py",
					"settings":
					{
						"buffer_size": 9626,
						"line_ending": "Unix"
					}
				},
				{
					"contents": "Searching 716 files for \"•\"\n\nC:\\Users\\cienet\\AppData\\Roaming\\Sublime Text 3\\Packages\\SFTP\\sftp\\commands.py:\n  685              if not is_root(self.remote_path):\n  686                  self.files.insert(1, '..')\n  687:                 self.entries.insert(1, ' • Up a folder')\n  688              self.files.insert(1, '.')\n  689:             self.entries.insert(1, ' • Folder actions')\n  690              self.existing_files = [\n  691               '.', '..']\n  ...\n  738          actions = [\n  739           '' + self.config['host'] + ':' + self.selected_path,\n  740:          ' • Back to list',\n  741:          ' • New file',\n  742:          ' • New folder',\n  743:          ' • Rename',\n  744:          ' • Chmod',\n  745:          ' • Delete']\n  746          if not self.config.get('is_tmp'):\n  747:             actions.insert(4, ' • Download')\n  748          show_qp(self.window, actions, self.modify_dir_action)\n  749  \n  ...\n  855          actions = [\n  856           '' + self.config['host'] + ':' + self.selected_path,\n  857:          ' • Back to list',\n  858:          ' • Edit',\n  859:          ' • Rename',\n  860:          ' • Chmod',\n  861:          ' • Delete']\n  862          if not self.config.get('is_tmp'):\n  863              actions[2] += ' (remote version)'\n  864:             actions.insert(3, ' • Download')\n  865          show_qp(self.window, actions, self.modify_file_action)\n  866  \n\n15 matches in 1 file\n",
					"settings":
					{
						"buffer_size": 1426,
						"line_ending": "Unix",
						"name": "Find Results",
						"scratch": true
					}
				},
				{
					"file": "/D/desktop/testpyc.py",
					"settings":
					{
						"buffer_size": 562,
						"encoding": "UTF-8",
						"line_ending": "Unix",
						"name": "import os"
					}
				}
			],
			"build_system": "",
			"build_system_choices":
			[
				[
					[
						[
							"Anaconda Python Builder",
							""
						],
						[
							"Packages/Python/Python.sublime-build",
							""
						],
						[
							"Packages/Python/Python.sublime-build",
							"Syntax Check"
						]
					],
					[
						"Packages/Python/Python.sublime-build",
						""
					]
				]
			],
			"build_varint": "",
			"command_palette":
			{
				"height": 0.0,
				"last_filter": "",
				"selected_items":
				[
					[
						"pci",
						"Package Control: Install Package"
					],
					[
						"pi",
						"Package Control: Install Package"
					],
					[
						"pacc",
						"Install Package Control"
					]
				],
				"width": 0.0
			},
			"console":
			{
				"height": 458.0,
				"history":
				[
				]
			},
			"distraction_free":
			{
				"menu_visible": true,
				"show_minimap": false,
				"show_open_files": false,
				"show_tabs": false,
				"side_bar_visible": false,
				"status_bar_visible": false
			},
			"expanded_folders":
			[
				"/D/desktop/py_test"
			],
			"file_history":
			[
				"/D/desktop/openacs/.git/config",
				"/C/Program Files/Sublime Text 3/Packages/Text.sublime-package",
				"/C/Program Files/Sublime Text 3/sublime.py",
				"/C/Users/cienet/AppData/Roaming/Sublime Text 3/Packages/SFTP/sftp/commands.py",
				"/D/desktop/直真日志/ACSServer.traces",
				"/D/desktop/直真日志/TR069Adaptor.traces",
				"/D/desktop/直真日志/ITFService.traces",
				"/C/Users/cienet/AppData/Roaming/Sublime Text 3/Packages/User/Anaconda.sublime-settings",
				"/D/hgu_autotestc103/Lib/Service/AC/bizAC.py",
				"/D/hgu_autotestc103/Service/AC/solocase/AC_TwoFilter_Black_015.py",
				"/D/hgu_autotestc103/Lib/Service/Start/bizStart.py",
				"/D/hgu_autotestc103/Lib/Service/AC/impACWeb.py",
				"/D/hgu_autotestc103/Service/AC/solocase/AC_ComplexFilter_Black_001.py",
				"/C/Users/cienet/AppData/Roaming/Sublime Text 3/Packages/Sublimerge Pro/Sublimerge.sublime-settings",
				"/C/Users/cienet/AppData/Roaming/Sublime Text 3/Packages/SFTP/SFTP.sublime-settings",
				"/C/Users/cienet/AppData/Roaming/Sublime Text 3/Packages/User/SFTP.sublime-settings",
				"/D/hgu_autotestc103/Service/Global.py",
				"/D/desktop/电信直真日志/TR069Adaptor.traces",
				"/D/desktop/电信直真日志/ACSServer.traces",
				"/D/desktop/电信直真日志/ITFService.traces",
				"/D/hgu_autotestc103/sftp-config.json",
				"/C/Users/cienet/AppData/Roaming/Sublime Text 3/Packages/SFTP/SFTP.py",
				"/C/Users/cienet/AppData/Roaming/Sublime Text 3/Packages/SublimeSimpleSync/SublimeSimpleSync.sublime-settings",
				"/C/Users/cienet/AppData/Roaming/Sublime Text 3/Packages/User/SublimeSimpleSync.sublime-settings",
				"/C/Users/cienet/Desktop/py_test/log01/__init__.py",
				"/C/Users/cienet/Desktop/py_test/conftest.py",
				"/C/Users/cienet/Desktop/py_test/pytest.ini",
				"/C/Users/cienet/Desktop/py_test/test_py_001.py",
				"/C/Users/cienet/Desktop/烽火/系统启动/资料/模块.py",
				"/C/Users/cienet/Desktop/py_test/test002.py",
				"/C/Users/cienet/Desktop/py_test/log01/test.log",
				"/C/Users/cienet/Desktop/py_test/log01/boss.log",
				"/C/Users/cienet/Desktop/py_test/log01/coder.log",
				"/C/Users/cienet/Desktop/py_test/log01",
				"/C/Users/cienet/Desktop/test.py",
				"/C/Users/cienet/Desktop/烽火/系统启动/资料/test.py",
				"/C/Users/cienet/Desktop/py_test/assets/console.py",
				"/C/Users/cienet/Desktop/py_test/report.html",
				"/C/Users/cienet/Desktop/py_test/bbb.py",
				"/C/Users/cienet/AppData/Roaming/Sublime Text 3/Packages/User/Word Highlight.sublime-settings",
				"/C/Users/cienet/AppData/Roaming/Sublime Text 3/Packages/WordHighlight/Word Highlight.sublime-settings",
				"/C/Users/cienet/AppData/Roaming/Sublime Text 3/Packages/SublimeCodeIntel/SublimeCodeIntel.sublime-settings",
				"/c/Python/lib/site-packages/pexpect/__init__.py",
				"/C/Users/cienet/AppData/Roaming/Sublime Text 3/Packages/CTags/CTags.sublime-settings",
				"//10.182.33.15/d$/FHATP/user/hgu_autotestc103/Lib/Service/BRDGMC/bizBRDGMC.py",
				"/C/Users/cienet/AppData/Roaming/Sublime Text 3/Packages/User/CTags.sublime-settings",
				"/C/Users/cienet/AppData/Roaming/Sublime Text 3/Packages/User/Default (Windows).sublime-keymap",
				"//10.182.33.15/d$/FHATP/user/hgu_autotestc103/Lib/general/hgu_telnet.py",
				"//10.182.33.15/d$/FHATP/user/hgu_autotestc103/Config/site_para.py",
				"//10.182.33.15/d$/FHATP/user/hgu_autotestc103/Lib/general/util_basic/absHGUProduct.py",
				"//10.182.33.15/d$/FHATP/user/hgu_autotestc103/Lib/general/util_basic/impWEBChn.py",
				"//10.182.33.15/d$/FHATP/user/hgu_autotestc103/Lib/Service/Start/bizStart.py",
				"/C/Users/cienet/AppData/Roaming/Sublime Text 3/Packages/User/SublimeCodeIntel.sublime-settings",
				"/C/Users/cienet/AppData/Roaming/Sublime Text 3/Packages/User/Package Control.sublime-settings",
				"/C/Users/cienet/AppData/Roaming/Sublime Text 3/Packages/Package Control/Package Control.sublime-settings"
			],
			"find":
			{
				"height": 34.0
			},
			"find_in_files":
			{
				"height": 261.0,
				"where_history":
				[
					""
				]
			},
			"find_state":
			{
				"case_sensitive": false,
				"find_history":
				[
					"reg",
					"•",
					"InternetGatewayDevice",
					"B/r/r",
					"B",
					"InternetGatewayDevice.DeviceInfo.SoftwareVersion",
					"sublime.set_timeout"
				],
				"highlight": true,
				"in_selection": false,
				"preserve_case": false,
				"regex": false,
				"replace_history":
				[
				],
				"reverse": false,
				"show_context": true,
				"use_buffer2": true,
				"whole_word": false,
				"wrap": true
			},
			"folders":
			[
				{
					"path": "D:\\desktop\\py_test"
				}
			],
			"groups":
			[
				{
					"selected": 2,
					"sheets":
					[
						{
							"buffer": 0,
							"file": "/D/desktop/py_test/test001.py",
							"semi_transient": false,
							"settings":
							{
								"buffer_size": 1057,
								"regions":
								{
								},
								"selection":
								[
									[
										323,
										323
									]
								],
								"settings":
								{
									"bracket_highlighter.busy": false,
									"bracket_highlighter.locations":
									{
										"close":
										{
										},
										"icon":
										{
										},
										"open":
										{
										},
										"unmatched":
										{
										}
									},
									"bracket_highlighter.regions":
									[
										"bh_unmatched",
										"bh_unmatched_center",
										"bh_unmatched_open",
										"bh_unmatched_close",
										"bh_unmatched_content",
										"bh_round",
										"bh_round_center",
										"bh_round_open",
										"bh_round_close",
										"bh_round_content",
										"bh_angle",
										"bh_angle_center",
										"bh_angle_open",
										"bh_angle_close",
										"bh_angle_content",
										"bh_default",
										"bh_default_center",
										"bh_default_open",
										"bh_default_close",
										"bh_default_content",
										"bh_single_quote",
										"bh_single_quote_center",
										"bh_single_quote_open",
										"bh_single_quote_close",
										"bh_single_quote_content",
										"bh_curly",
										"bh_curly_center",
										"bh_curly_open",
										"bh_curly_close",
										"bh_curly_content",
										"bh_c_define",
										"bh_c_define_center",
										"bh_c_define_open",
										"bh_c_define_close",
										"bh_c_define_content",
										"bh_regex",
										"bh_regex_center",
										"bh_regex_open",
										"bh_regex_close",
										"bh_regex_content",
										"bh_tag",
										"bh_tag_center",
										"bh_tag_open",
										"bh_tag_close",
										"bh_tag_content",
										"bh_square",
										"bh_square_center",
										"bh_square_open",
										"bh_square_close",
										"bh_square_content",
										"bh_double_quote",
										"bh_double_quote_center",
										"bh_double_quote_open",
										"bh_double_quote_close",
										"bh_double_quote_content"
									],
									"c_time":
									[
										128,
										3,
										99,
										100,
										97,
										116,
										101,
										116,
										105,
										109,
										101,
										10,
										100,
										97,
										116,
										101,
										116,
										105,
										109,
										101,
										10,
										113,
										0,
										67,
										10,
										7,
										228,
										11,
										5,
										9,
										21,
										24,
										11,
										137,
										22,
										113,
										1,
										133,
										113,
										2,
										82,
										113,
										3,
										46
									],
									"incomplete_sync": null,
									"remote_loading": false,
									"synced": false,
									"syntax": "Packages/Python/Python.sublime-syntax",
									"tab_size": 4,
									"translate_tabs_to_spaces": true
								},
								"translation.x": 0.0,
								"translation.y": 150.0,
								"zoom_level": 1.0
							},
							"stack_index": 7,
							"type": "text"
						},
						{
							"buffer": 1,
							"file": "/D/desktop/py_test/bbb.py",
							"semi_transient": false,
							"settings":
							{
								"buffer_size": 2949,
								"regions":
								{
								},
								"selection":
								[
									[
										987,
										987
									]
								],
								"settings":
								{
									"bracket_highlighter.busy": false,
									"bracket_highlighter.locations":
									{
										"close":
										{
										},
										"icon":
										{
										},
										"open":
										{
										},
										"unmatched":
										{
										}
									},
									"bracket_highlighter.regions":
									[
										"bh_angle",
										"bh_angle_center",
										"bh_angle_open",
										"bh_angle_close",
										"bh_angle_content",
										"bh_square",
										"bh_square_center",
										"bh_square_open",
										"bh_square_close",
										"bh_square_content",
										"bh_default",
										"bh_default_center",
										"bh_default_open",
										"bh_default_close",
										"bh_default_content",
										"bh_c_define",
										"bh_c_define_center",
										"bh_c_define_open",
										"bh_c_define_close",
										"bh_c_define_content",
										"bh_unmatched",
										"bh_unmatched_center",
										"bh_unmatched_open",
										"bh_unmatched_close",
										"bh_unmatched_content",
										"bh_single_quote",
										"bh_single_quote_center",
										"bh_single_quote_open",
										"bh_single_quote_close",
										"bh_single_quote_content",
										"bh_double_quote",
										"bh_double_quote_center",
										"bh_double_quote_open",
										"bh_double_quote_close",
										"bh_double_quote_content",
										"bh_regex",
										"bh_regex_center",
										"bh_regex_open",
										"bh_regex_close",
										"bh_regex_content",
										"bh_tag",
										"bh_tag_center",
										"bh_tag_open",
										"bh_tag_close",
										"bh_tag_content",
										"bh_curly",
										"bh_curly_center",
										"bh_curly_open",
										"bh_curly_close",
										"bh_curly_content",
										"bh_round",
										"bh_round_center",
										"bh_round_open",
										"bh_round_close",
										"bh_round_content"
									],
									"c_time":
									[
										128,
										3,
										99,
										100,
										97,
										116,
										101,
										116,
										105,
										109,
										101,
										10,
										100,
										97,
										116,
										101,
										116,
										105,
										109,
										101,
										10,
										113,
										0,
										67,
										10,
										7,
										228,
										11,
										5,
										9,
										21,
										24,
										11,
										86,
										111,
										113,
										1,
										133,
										113,
										2,
										82,
										113,
										3,
										46
									],
									"incomplete_sync": null,
									"remote_loading": false,
									"synced": false,
									"syntax": "Packages/Python/Python.sublime-syntax"
								},
								"translation.x": 0.0,
								"translation.y": 1002.0,
								"zoom_level": 1.0
							},
							"stack_index": 6,
							"type": "text"
						},
						{
							"buffer": 2,
							"file": "/D/desktop/test.py",
							"semi_transient": false,
							"settings":
							{
								"buffer_size": 11903,
								"regions":
								{
								},
								"selection":
								[
									[
										11902,
										10443
									]
								],
								"settings":
								{
									"bracket_highlighter.busy": false,
									"bracket_highlighter.locations":
									{
										"close":
										{
										},
										"icon":
										{
										},
										"open":
										{
										},
										"unmatched":
										{
										}
									},
									"bracket_highlighter.regions":
									[
										"bh_angle",
										"bh_angle_center",
										"bh_angle_open",
										"bh_angle_close",
										"bh_angle_content",
										"bh_square",
										"bh_square_center",
										"bh_square_open",
										"bh_square_close",
										"bh_square_content",
										"bh_default",
										"bh_default_center",
										"bh_default_open",
										"bh_default_close",
										"bh_default_content",
										"bh_c_define",
										"bh_c_define_center",
										"bh_c_define_open",
										"bh_c_define_close",
										"bh_c_define_content",
										"bh_unmatched",
										"bh_unmatched_center",
										"bh_unmatched_open",
										"bh_unmatched_close",
										"bh_unmatched_content",
										"bh_single_quote",
										"bh_single_quote_center",
										"bh_single_quote_open",
										"bh_single_quote_close",
										"bh_single_quote_content",
										"bh_double_quote",
										"bh_double_quote_center",
										"bh_double_quote_open",
										"bh_double_quote_close",
										"bh_double_quote_content",
										"bh_regex",
										"bh_regex_center",
										"bh_regex_open",
										"bh_regex_close",
										"bh_regex_content",
										"bh_tag",
										"bh_tag_center",
										"bh_tag_open",
										"bh_tag_close",
										"bh_tag_content",
										"bh_curly",
										"bh_curly_center",
										"bh_curly_open",
										"bh_curly_close",
										"bh_curly_content",
										"bh_round",
										"bh_round_center",
										"bh_round_open",
										"bh_round_close",
										"bh_round_content"
									],
									"c_time":
									[
										128,
										3,
										99,
										100,
										97,
										116,
										101,
										116,
										105,
										109,
										101,
										10,
										100,
										97,
										116,
										101,
										116,
										105,
										109,
										101,
										10,
										113,
										0,
										67,
										10,
										7,
										228,
										11,
										5,
										9,
										21,
										22,
										3,
										118,
										60,
										113,
										1,
										133,
										113,
										2,
										82,
										113,
										3,
										46
									],
									"incomplete_sync": null,
									"remote_loading": false,
									"synced": false,
									"syntax": "Packages/Python/Python.sublime-syntax"
								},
								"translation.x": 0.0,
								"translation.y": 163.0,
								"zoom_level": 1.0
							},
							"stack_index": 0,
							"type": "text"
						},
						{
							"buffer": 3,
							"file": "/D/desktop/py_test/test002.py",
							"semi_transient": false,
							"settings":
							{
								"buffer_size": 618344,
								"regions":
								{
								},
								"selection":
								[
									[
										0,
										618344
									]
								],
								"settings":
								{
									"bracket_highlighter.busy": false,
									"bracket_highlighter.locations":
									{
										"close":
										{
										},
										"icon":
										{
										},
										"open":
										{
										},
										"unmatched":
										{
										}
									},
									"bracket_highlighter.regions":
									[
										"bh_angle",
										"bh_angle_center",
										"bh_angle_open",
										"bh_angle_close",
										"bh_angle_content",
										"bh_square",
										"bh_square_center",
										"bh_square_open",
										"bh_square_close",
										"bh_square_content",
										"bh_default",
										"bh_default_center",
										"bh_default_open",
										"bh_default_close",
										"bh_default_content",
										"bh_c_define",
										"bh_c_define_center",
										"bh_c_define_open",
										"bh_c_define_close",
										"bh_c_define_content",
										"bh_unmatched",
										"bh_unmatched_center",
										"bh_unmatched_open",
										"bh_unmatched_close",
										"bh_unmatched_content",
										"bh_single_quote",
										"bh_single_quote_center",
										"bh_single_quote_open",
										"bh_single_quote_close",
										"bh_single_quote_content",
										"bh_double_quote",
										"bh_double_quote_center",
										"bh_double_quote_open",
										"bh_double_quote_close",
										"bh_double_quote_content",
										"bh_regex",
										"bh_regex_center",
										"bh_regex_open",
										"bh_regex_close",
										"bh_regex_content",
										"bh_tag",
										"bh_tag_center",
										"bh_tag_open",
										"bh_tag_close",
										"bh_tag_content",
										"bh_curly",
										"bh_curly_center",
										"bh_curly_open",
										"bh_curly_close",
										"bh_curly_content",
										"bh_round",
										"bh_round_center",
										"bh_round_open",
										"bh_round_close",
										"bh_round_content"
									],
									"c_time":
									[
										128,
										3,
										99,
										100,
										97,
										116,
										101,
										116,
										105,
										109,
										101,
										10,
										100,
										97,
										116,
										101,
										116,
										105,
										109,
										101,
										10,
										113,
										0,
										67,
										10,
										7,
										228,
										11,
										5,
										9,
										21,
										24,
										11,
										152,
										169,
										113,
										1,
										133,
										113,
										2,
										82,
										113,
										3,
										46
									],
									"incomplete_sync": null,
									"remote_loading": false,
									"synced": false,
									"syntax": "Packages/Python/Python.sublime-syntax",
									"tab_size": 4,
									"translate_tabs_to_spaces": true
								},
								"translation.x": 0.0,
								"translation.y": 3667.0,
								"zoom_level": 1.0
							},
							"stack_index": 4,
							"type": "text"
						},
						{
							"buffer": 4,
							"file": "/C/Users/cienet/AppData/Roaming/Sublime Text 3/Packages/SFTP/sftp/commands.py",
							"semi_transient": false,
							"settings":
							{
								"buffer_size": 123677,
								"regions":
								{
								},
								"selection":
								[
									[
										10845,
										10845
									]
								],
								"settings":
								{
									"bracket_highlighter.busy": false,
									"bracket_highlighter.locations":
									{
										"close":
										{
										},
										"icon":
										{
										},
										"open":
										{
										},
										"unmatched":
										{
										}
									},
									"bracket_highlighter.regions":
									[
										"bh_angle",
										"bh_angle_center",
										"bh_angle_open",
										"bh_angle_close",
										"bh_angle_content",
										"bh_square",
										"bh_square_center",
										"bh_square_open",
										"bh_square_close",
										"bh_square_content",
										"bh_default",
										"bh_default_center",
										"bh_default_open",
										"bh_default_close",
										"bh_default_content",
										"bh_c_define",
										"bh_c_define_center",
										"bh_c_define_open",
										"bh_c_define_close",
										"bh_c_define_content",
										"bh_unmatched",
										"bh_unmatched_center",
										"bh_unmatched_open",
										"bh_unmatched_close",
										"bh_unmatched_content",
										"bh_single_quote",
										"bh_single_quote_center",
										"bh_single_quote_open",
										"bh_single_quote_close",
										"bh_single_quote_content",
										"bh_double_quote",
										"bh_double_quote_center",
										"bh_double_quote_open",
										"bh_double_quote_close",
										"bh_double_quote_content",
										"bh_regex",
										"bh_regex_center",
										"bh_regex_open",
										"bh_regex_close",
										"bh_regex_content",
										"bh_tag",
										"bh_tag_center",
										"bh_tag_open",
										"bh_tag_close",
										"bh_tag_content",
										"bh_curly",
										"bh_curly_center",
										"bh_curly_open",
										"bh_curly_close",
										"bh_curly_content",
										"bh_round",
										"bh_round_center",
										"bh_round_open",
										"bh_round_close",
										"bh_round_content"
									],
									"c_time":
									[
										128,
										3,
										99,
										100,
										97,
										116,
										101,
										116,
										105,
										109,
										101,
										10,
										100,
										97,
										116,
										101,
										116,
										105,
										109,
										101,
										10,
										113,
										0,
										67,
										10,
										7,
										228,
										11,
										11,
										18,
										35,
										54,
										11,
										87,
										55,
										113,
										1,
										133,
										113,
										2,
										82,
										113,
										3,
										46
									],
									"incomplete_sync": null,
									"remote_loading": false,
									"synced": false,
									"syntax": "Packages/Python/Python.sublime-syntax",
									"tab_size": 4,
									"translate_tabs_to_spaces": true
								},
								"translation.x": 0.0,
								"translation.y": 8586.0,
								"zoom_level": 1.0
							},
							"stack_index": 3,
							"type": "text"
						},
						{
							"buffer": 5,
							"file": "/C/Users/cienet/AppData/Roaming/Sublime Text 3/Packages/SFTP/SFTP.py",
							"semi_transient": false,
							"settings":
							{
								"buffer_size": 9626,
								"regions":
								{
								},
								"selection":
								[
									[
										936,
										936
									]
								],
								"settings":
								{
									"bracket_highlighter.busy": false,
									"bracket_highlighter.locations":
									{
										"close":
										{
											"1":
											[
												1283,
												1284
											]
										},
										"icon":
										{
											"1":
											[
												"Packages/BracketHighlighter/icons/square_bracket.png",
												"region.bluish"
											]
										},
										"open":
										{
											"1":
											[
												887,
												888
											]
										},
										"unmatched":
										{
										}
									},
									"bracket_highlighter.regions":
									[
										"bh_angle",
										"bh_angle_center",
										"bh_angle_open",
										"bh_angle_close",
										"bh_angle_content",
										"bh_square",
										"bh_square_center",
										"bh_square_open",
										"bh_square_close",
										"bh_square_content",
										"bh_default",
										"bh_default_center",
										"bh_default_open",
										"bh_default_close",
										"bh_default_content",
										"bh_c_define",
										"bh_c_define_center",
										"bh_c_define_open",
										"bh_c_define_close",
										"bh_c_define_content",
										"bh_unmatched",
										"bh_unmatched_center",
										"bh_unmatched_open",
										"bh_unmatched_close",
										"bh_unmatched_content",
										"bh_single_quote",
										"bh_single_quote_center",
										"bh_single_quote_open",
										"bh_single_quote_close",
										"bh_single_quote_content",
										"bh_double_quote",
										"bh_double_quote_center",
										"bh_double_quote_open",
										"bh_double_quote_close",
										"bh_double_quote_content",
										"bh_regex",
										"bh_regex_center",
										"bh_regex_open",
										"bh_regex_close",
										"bh_regex_content",
										"bh_tag",
										"bh_tag_center",
										"bh_tag_open",
										"bh_tag_close",
										"bh_tag_content",
										"bh_curly",
										"bh_curly_center",
										"bh_curly_open",
										"bh_curly_close",
										"bh_curly_content",
										"bh_round",
										"bh_round_center",
										"bh_round_open",
										"bh_round_close",
										"bh_round_content"
									],
									"c_time":
									[
										128,
										3,
										99,
										100,
										97,
										116,
										101,
										116,
										105,
										109,
										101,
										10,
										100,
										97,
										116,
										101,
										116,
										105,
										109,
										101,
										10,
										113,
										0,
										67,
										10,
										7,
										228,
										11,
										5,
										10,
										41,
										30,
										5,
										184,
										51,
										113,
										1,
										133,
										113,
										2,
										82,
										113,
										3,
										46
									],
									"incomplete_sync": null,
									"syntax": "Packages/Python/Python.sublime-syntax",
									"tab_size": 4,
									"translate_tabs_to_spaces": true
								},
								"translation.x": 0.0,
								"translation.y": 993.0,
								"zoom_level": 1.0
							},
							"stack_index": 2,
							"type": "text"
						},
						{
							"buffer": 6,
							"semi_transient": false,
							"settings":
							{
								"buffer_size": 1426,
								"regions":
								{
									"match":
									{
										"flags": 112,
										"regions":
										[
											[
												259,
												260
											],
											[
												364,
												365
											],
											[
												577,
												578
											],
											[
												612,
												613
											],
											[
												643,
												644
											],
											[
												676,
												677
											],
											[
												705,
												706
											],
											[
												733,
												734
											],
											[
												832,
												833
											],
											[
												1042,
												1043
											],
											[
												1077,
												1078
											],
											[
												1104,
												1105
											],
											[
												1133,
												1134
											],
											[
												1161,
												1162
											],
											[
												1313,
												1314
											]
										],
										"scope": ""
									}
								},
								"selection":
								[
									[
										0,
										0
									]
								],
								"settings":
								{
									"bracket_highlighter.busy": false,
									"bracket_highlighter.locations":
									{
										"close":
										{
										},
										"icon":
										{
										},
										"open":
										{
										},
										"unmatched":
										{
										}
									},
									"bracket_highlighter.regions":
									[
										"bh_angle",
										"bh_angle_center",
										"bh_angle_open",
										"bh_angle_close",
										"bh_angle_content",
										"bh_square",
										"bh_square_center",
										"bh_square_open",
										"bh_square_close",
										"bh_square_content",
										"bh_default",
										"bh_default_center",
										"bh_default_open",
										"bh_default_close",
										"bh_default_content",
										"bh_c_define",
										"bh_c_define_center",
										"bh_c_define_open",
										"bh_c_define_close",
										"bh_c_define_content",
										"bh_unmatched",
										"bh_unmatched_center",
										"bh_unmatched_open",
										"bh_unmatched_close",
										"bh_unmatched_content",
										"bh_single_quote",
										"bh_single_quote_center",
										"bh_single_quote_open",
										"bh_single_quote_close",
										"bh_single_quote_content",
										"bh_double_quote",
										"bh_double_quote_center",
										"bh_double_quote_open",
										"bh_double_quote_close",
										"bh_double_quote_content",
										"bh_regex",
										"bh_regex_center",
										"bh_regex_open",
										"bh_regex_close",
										"bh_regex_content",
										"bh_tag",
										"bh_tag_center",
										"bh_tag_open",
										"bh_tag_close",
										"bh_tag_content",
										"bh_curly",
										"bh_curly_center",
										"bh_curly_open",
										"bh_curly_close",
										"bh_curly_content",
										"bh_round",
										"bh_round_center",
										"bh_round_open",
										"bh_round_close",
										"bh_round_content"
									],
									"default_dir": "C:\\Users\\cienet\\AppData\\Roaming\\Sublime Text 3\\Packages\\SFTP\\sftp",
									"detect_indentation": false,
									"line_numbers": false,
									"output_tag": 1,
									"result_base_dir": "",
									"result_file_regex": "^([^ \t].*):$",
									"result_line_regex": "^ +([0-9]+):",
									"scroll_past_end": true,
									"syntax": "Packages/Default/Find Results.hidden-tmLanguage",
									"translate_tabs_to_spaces": false
								},
								"translation.x": 0.0,
								"translation.y": 597.0,
								"zoom_level": 1.0
							},
							"stack_index": 5,
							"type": "text"
						},
						{
							"buffer": 7,
							"file": "/D/desktop/testpyc.py",
							"semi_transient": false,
							"settings":
							{
								"buffer_size": 562,
								"regions":
								{
								},
								"selection":
								[
									[
										550,
										550
									]
								],
								"settings":
								{
									"auto_name": "import os",
									"bracket_highlighter.busy": false,
									"bracket_highlighter.locations":
									{
										"close":
										{
											"1":
											[
												559,
												560
											]
										},
										"icon":
										{
											"1":
											[
												"Packages/BracketHighlighter/icons/round_bracket.png",
												"region.yellowish"
											]
										},
										"open":
										{
											"1":
											[
												531,
												532
											]
										},
										"unmatched":
										{
										}
									},
									"bracket_highlighter.regions":
									[
										"bh_angle",
										"bh_angle_center",
										"bh_angle_open",
										"bh_angle_close",
										"bh_angle_content",
										"bh_square",
										"bh_square_center",
										"bh_square_open",
										"bh_square_close",
										"bh_square_content",
										"bh_default",
										"bh_default_center",
										"bh_default_open",
										"bh_default_close",
										"bh_default_content",
										"bh_c_define",
										"bh_c_define_center",
										"bh_c_define_open",
										"bh_c_define_close",
										"bh_c_define_content",
										"bh_unmatched",
										"bh_unmatched_center",
										"bh_unmatched_open",
										"bh_unmatched_close",
										"bh_unmatched_content",
										"bh_single_quote",
										"bh_single_quote_center",
										"bh_single_quote_open",
										"bh_single_quote_close",
										"bh_single_quote_content",
										"bh_double_quote",
										"bh_double_quote_center",
										"bh_double_quote_open",
										"bh_double_quote_close",
										"bh_double_quote_content",
										"bh_regex",
										"bh_regex_center",
										"bh_regex_open",
										"bh_regex_close",
										"bh_regex_content",
										"bh_tag",
										"bh_tag_center",
										"bh_tag_open",
										"bh_tag_close",
										"bh_tag_content",
										"bh_curly",
										"bh_curly_center",
										"bh_curly_open",
										"bh_curly_close",
										"bh_curly_content",
										"bh_round",
										"bh_round_center",
										"bh_round_open",
										"bh_round_close",
										"bh_round_content"
									],
									"c_time":
									[
										128,
										3,
										99,
										100,
										97,
										116,
										101,
										116,
										105,
										109,
										101,
										10,
										100,
										97,
										116,
										101,
										116,
										105,
										109,
										101,
										10,
										113,
										0,
										67,
										10,
										7,
										228,
										11,
										11,
										18,
										59,
										30,
										12,
										103,
										17,
										113,
										1,
										133,
										113,
										2,
										82,
										113,
										3,
										46
									],
									"syntax": "Packages/Python/Python.sublime-syntax"
								},
								"translation.x": 0.0,
								"translation.y": 3.0,
								"zoom_level": 1.0
							},
							"stack_index": 1,
							"type": "text"
						}
					]
				}
			],
			"incremental_find":
			{
				"height": 34.0
			},
			"input":
			{
				"height": 71.0
			},
			"layout":
			{
				"cells":
				[
					[
						0,
						0,
						1,
						1
					]
				],
				"cols":
				[
					0.0,
					1.0
				],
				"rows":
				[
					0.0,
					1.0
				]
			},
			"menu_visible": true,
			"output.exec":
			{
				"height": 427.0
			},
			"output.find_results":
			{
				"height": 0.0
			},
			"output.sftp":
			{
				"height": 151.0
			},
			"pinned_build_system": "",
			"position": "0,0,2,-32000,-32000,-1,-1,415,0,57,897",
			"project": "",
			"replace":
			{
				"height": 64.0
			},
			"save_all_on_build": true,
			"select_file":
			{
				"height": 0.0,
				"last_filter": "",
				"selected_items":
				[
					[
						"glob",
						"Service\\Global.py"
					],
					[
						"bizstart",
						"Lib\\Service\\Start\\bizStart.py"
					],
					[
						"abshgu",
						"Lib\\general\\util_basic\\absHGUProduct.py"
					],
					[
						"hgutel",
						"Lib\\general\\hgu_telnet.py"
					],
					[
						"impwe",
						"Lib\\general\\util_basic\\impWEBChn.py"
					]
				],
				"width": 0.0
			},
			"select_project":
			{
				"height": 0.0,
				"last_filter": "",
				"selected_items":
				[
				],
				"width": 0.0
			},
			"select_symbol":
			{
				"height": 0.0,
				"last_filter": "",
				"selected_items":
				[
				],
				"width": 0.0
			},
			"selected_group": 0,
			"settings":
			{
			},
			"show_minimap": true,
			"show_open_files": false,
			"show_tabs": true,
			"side_bar_visible": false,
			"side_bar_width": 266.0,
			"status_bar_visible": true,
			"template_settings":
			{
			},
			"window_id": 80,
			"workspace_name": ""
		}
	],
	"workspaces":
	{
		"recent_workspaces":
		[
		]
	}
}
